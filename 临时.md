1.快速排序

```C++
void quick_sort(int a[], int left, int right) {
    if(left >= right)
        return;
    
    int less = left - 1;
    int more = right + 1;
    int cur = left;
    int ran = (rand() % (right - left + 1)) + left;
    swap(a, ran, right);
    int index = a[right];
    while(cur < more) {
        if(a[cur] < index) {
            swap(a, ++less, cur++);
        }
        else if(a[cur] > index) {
            swap(a, --more, cur);
        }
        else {
            cur++;
        }
    }
    
    quick_sort(a, left, less);
    quick_sort(a, more, right);
}
```



2.归并排序

```C++
void merge_sort(int a[], int left, int right) {
    if(left >= right)
        return;
    
    int mid = left + (right - left) / 2;
    merge_sort(a, left, mid);
    merge_sort(a, mid + 1, right);
    merge(a, left, mid, right);
}

void merge(int a[], int left, int mid, innt right) {
    int size = right - left + 1;
    int temp[size];
    int t1 = 0;
    int t2 = mid + 1;
    int index = 0;
    
    while(t1 <= mid && t2 <= right) {
        temp[index++] = a[t1] < a[t2] ? a[t1++] : a[t2++];
    }
    
    while(t1 <= mid) {
        temp[index++] = a[t1++];
    }
    
    while(t2 <= right) {
        temp[index++] = a[t2++];
    }
    
    for(int i = 0; i < size; i++) {
        a[left + i] = temp[i];
    }
}
```



3.堆排序&Top K

```C++
// 递归方式构建大根堆(len是arr的长度，index是第一个非叶子节点的下标)
void adjust(vector<int> &arr, int len, int index)
{
    int left = 2 * index + 1; // index的左子节点
    int right = 2 * index + 2;// index的右子节点
 
    //找左孩子、右孩子、根三者中较大的那个
    int maxIdx = index;
    if(left<len && arr[left] > arr[maxIdx])
        maxIdx = left;
    if(right<len && arr[right] > arr[maxIdx])
        maxIdx = right;
    //如果
    if(maxIdx != index)
    {
        swap(arr[maxIdx], arr[index]);
        adjust(arr, len, maxIdx);
    }
 
}
 
// 堆排序
void heapSort(vector<int> &arr, int size)
{
    // 构建大根堆（从最后一个非叶子节点向上）
    for(int i = size/2 - 1; i >= 0; i--)
    {
        adjust(arr, size, i);
    }
 
    // 调整大根堆
    for(int i = size - 1; i >= 1; i--)
    {
        swap(arr[0], arr[i]);           // 将当前最大的放置到数组末尾
        adjust(arr, i, 0);              // 将未完成排序的部分继续进行堆排序
    }
}

void top_min_k(vector<int> v, int k) {
    if(v.size() <= 0 || k <=0)
        return;
    vector<int> res;
    for(int i = 0; i < k; i++) {
        res.push_back(v[i]);
    }
    make_heap(res.begin(), res.end(), less<int>());

    for(int i = k; i < v.size(); i++) {
        if(v[i] < res[0]) {
            res[0] = v[i];
            make_heap(res.begin(), res.end(), less<int>());
        }
    }
    sort_heap(res.begin(), res.end());
}

void top_max_k(vector<int> v, int k) {
    if(v.size() <= 0 || k <=0)
        return;
    vector<int> res;
    for(int i = 0; i < k; i++) {
        res.push_back(v[i]);
    }
    make_heap(res.begin(), res.end(), greater<int>());

    for(int i = k; i < v.size(); i++) {
        if(v[i] > res[0]) {
            res[0] = v[i];
            make_heap(res.begin(), res.end(), greater<int>());
        }
    }
    sort_heap(res.begin(), res.end());
}
```



4.排序的时间复杂度总结

| 排序算法                                                     | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性       |
| ------------------------------------------------------------ | -------------- | -------------- | ---------- | -------------------- |
| [冒泡排序](https://github.com/huihut/interview/blob/master/Algorithm/BubbleSort.h) | O(n2)          | O(n2)          | O(1)       | 稳定                 |
| [选择排序](https://github.com/huihut/interview/blob/master/Algorithm/SelectionSort.h) | O(n2)          | O(n2)          | O(1)       | 数组不稳定、链表稳定 |
| [插入排序](https://github.com/huihut/interview/blob/master/Algorithm/InsertSort.h) | O(n2)          | O(n2)          | O(1)       | 稳定                 |
| [快速排序](https://github.com/huihut/interview/blob/master/Algorithm/QuickSort.h) | O(n*log2n)     | O(n2)          | O(log2n)   | 不稳定               |
| [堆排序](https://github.com/huihut/interview/blob/master/Algorithm/HeapSort.cpp) | O(n*log2n)     | O(n*log2n)     | O(1)       | 不稳定               |
| [归并排序](https://github.com/huihut/interview/blob/master/Algorithm/MergeSort.h) | O(n*log2n)     | O(n*log2n)     | O(n)       | 稳定                 |
| [希尔排序](https://github.com/huihut/interview/blob/master/Algorithm/ShellSort.h) | O(n*log2n)     | O(n2)          | O(1)       | 不稳定               |
| [计数排序](https://github.com/huihut/interview/blob/master/Algorithm/CountSort.cpp) | O(n+m)         | O(n+m)         | O(n+m)     | 稳定                 |
| [桶排序](https://github.com/huihut/interview/blob/master/Algorithm/BucketSort.cpp) | O(n)           | O(n)           | O(m)       | 稳定                 |
| [基数排序](https://github.com/huihut/interview/blob/master/Algorithm/RadixSort.h) | O(k*n)         | O(n2)          |            | 稳定                 |



5.删除链表的倒数第k个节点



```C++
    ListNode* remove_Nth_FromEnd(ListNode* head, int n) {
        if(head == NULL)
            return head;
        ListNode *fast = head;
        ListNode *slow = head;
        for(int i = 0; i < n; i++) {
            if(fast == NULL)
                return head;
            fast = fast->next;
        }
        if(fast == NULL)
            return head->next;
        
        while(fast->next) {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return head;
    }
```



6.链表反转



```C++
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == NULL)
            return NULL;
        ListNode *now = pHead;
        ListNode *pre = NULL;
        ListNode *p_next = NULL;
        
        ListNode *res = NULL;
        
        while(now != NULL) {
            p_next = now->next;
            if(p_next == NULL)
                res = now;
            
            now->next = pre;
            pre = now;
            now = p_next;
        }
        
        return res;
    }
```



7.洗牌算法



```C++
void shuffle(int cards[],int n)
{
    if(cards==NULL)
        return ;
    srand(time(0));
    for(int i=0;i<n-1;++i) {
        int index = i + rand() % (n-i);
        int temp = cards[i];
        cards[i] = cards[index];
        cards[index] = temp;
    }
}
```



8.非递归遍历二叉树 & 层次遍历



```C++
//非递归-中序
void pre_order(Node *head) {
    if(head == NULL)
        return;
    stack<Node*> s;
    while(head != NULL || !s.empty()) {
        if(head != NULL) {
            s.push(head->left);
            head = head->left;
        }
        else {
            head = s.top();
            s.pop();
            cout << head->value << endl;
            head = head->right;
        }
    }
}

//层次遍历
void level_order(Node *head) {
    if(head == NULL) {
        return;
    }
    queue<Node*> q;
    q.push(head);
    while(!q.empty()) {
        Node *tmp = q.front();
        q.pop();
        if(tmp != NULL) {
            cout << tmp->value << endl;
            q.push(tmp->left);
            q.push(tmp->right);
        }
    }
}
```



9.二叉树的高度



```C++
    int maxDepth(TreeNode* root) {
        if(root == NULL) {
            return 0;
        }
        
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        
        return (left > right) ? left + 1 : right + 1;
    }
```



10.反转字符串



```C++
void reserse_string(char *s) {
    if(s == NULL)
        return;
    
    int len = strlen(s);
    for(int i = 0, j = len - 1; i < j; i++,j--) {
        char c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}
```



11.最大回文子串



```C++
    string longestPalindrome(string s) {
        int n = s.size();
        if(n < 2)
            return s;
        
		vector<vector<bool> > state(n, vector<bool>(n, false));
		int start = 0, max_len = 1;
        /* 初始化状态矩阵 */
		for (int i = 0; i < n; i++) {
			state[i][i] = true;
			if (s[i] == s[i + 1]) {//两个字符相等时回文
				state[i][i + 1] = true;
				start = i;
				max_len = 2;
			}
		}
        
		for (int len = 3; len <= n; len++) {
			for (int i = 0; i <= n - len; i++) {
				int j = i + len - 1;
				if ((s[i] == s[j]) && (state[i + 1][j - 1])) {
					state[i][j] = true;
					start = i;
					max_len = len;
				}
			}
		}

		return s.substr(start, max_len);;
    }
```



12.最长重复子串



```C++
	string maxRepat(string input) {
        if(input == null || input.length() == 0){
            return null;
        }
        int max = Integer.MIN_VALUE;
        int k = Integer.MIN_VALUE;
        int first = 0;
        for (int i = 1; i < input.length(); i++) {
            for (int j = 0; j < input.length() - i; j++) {
                if(input[j] == input[i + j]){
                    k++;
                }
                else{
                    k = 0;
                }

                if(k > max){
                    max = k;
                    first = j - k + 1;
                }
            }
        }

        return input.substr(first, max);
    }
```



13.只出现一次的数字/求众数



```C++
    int singleNumber(vector<int>& nums) {
        if(nums.size() <= 0) {
            return 0;
        }
        int res = nums[0];
        for(int i = 1; i < nums.size(); i++) {
            res = res ^ nums[i];
        }
        
        return res;
    }

    int majorityElement(vector<int>& nums) {
        int len = nums.size();
        int res = nums[0];
        int times = 1;
        for(int i = 1; i < len; i++) {
            if(times <= 0) {
                res = nums[i];
                times = 1;
            }
            else {
                times = (nums[i] == res) ? times + 1 : times - 1;
            }
        }
        
        return res;
    }
```



14.滑动窗口的最大值



```C++
    vector<int> maxInWindows(const vector<int>& num, unsigned int size)
    {
        vector<int> maxInWindows;
        // 数组大小要大于等于窗口大小，并且窗口大小大于等于1
        if(num.size() >= size && size >= 1){
            deque<int> index;
            for(unsigned int i = 0; i < size; i++){
                // 如果index非空，并且新添加的数字大于等于队列中最小的数字，则删除队列中最小的数字
                while(!index.empty() && num[i] >= num[index.back()]){
                    index.pop_back();
                }
                index.push_back(i);
            }
            for(unsigned int i = size; i < num.size(); i++){
                maxInWindows.push_back(num[index.front()]);
                while(!index.empty() && num[i] >= num[index.back()]){
                    index.pop_back();
                }
                // 控制窗口大小为size
                if(!index.empty() && index.front() <= int(i - size)){
                    index.pop_front();
                }
                index.push_back(i);
            }
            maxInWindows.push_back(num[index.front()]);
        }
        return maxInWindows;
    }
```



15.合并链表/数组



```C++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == NULL) {
             return l2;
        }
        else if (l2 == NULL) {
            return l1;
        }
        else {
            if (l1->val <= l2->val) {
                l1->next = mergeTwoLists(l1->next, l2);
                return l1;
            }
            else {
                l2->next = mergeTwoLists(l1, l2->next);
                return l2;
            }
        }
    }
```



16.二叉树的最近公共祖先



```C++
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr || root == p || root == q){
            return root; 
        }
        
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        
        return left == nullptr? right : (right == nullptr? left : root);
    }
```



17.质数判断 & 反转Int



```C++
int reverse(int x) {              
    long result = 0;       // 注意这里要用long类型                        
    while (x != 0) {
        result = result * 10 + x % 10;       
        if (result > INT_MAX || result < INT_MIN) {
            return 0;
        }
        x = x / 10;
    }
    return (int)result;
}

bool isPrimeNumber(int num){  
    if(num == 2) 
        return true;//2特殊处理  
    if(num < 2 || num % 2 == 0) 
        return false;//识别小于2的数和偶数  
    for(int i=3; i<= sqrt(num); i+=2){  
        if(num % i == 0){//识别被奇数整除  
            return false;  
        }  
    }  
    return true;  
} 

```



18.两数之和



```C++
vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        unordered_map<int,int> m;
        for(int i = 0; i < nums.size(); i++)
        {
            int another = target - nums[i];
            if(m.find(another) != m.end())
            {
                res.push_back(m[another]);
                res.push_back(i);
                return res;
            }
            m[nums[i]] = i;
        }
        
        return res;
    }
```



19.字符串转整数



```C++
    int myAtoi(string str) {
        if(str.size() <= 0)
            return 0;
        
        int len = str.size();
        int i = 0;
        
        //找到第一个非空格的字符
        while(i < len) {
            if(str[i] != ' ')
                break;
            i++;
        }
        //如果全是空格
        if(i == len)
            return 0;
        
        //运算符正负号
        bool flag = false;
        if(str[i] == '-' && str[i+1] != '+') {
            flag = true;
            i++;
        }
        
        if(str[i] == '+' && str[i+1] != '-')
            i++;
        
        long long res = 0;
        while(i < len && str[i] >= '0' && str[i] <= '9') {
            res = res * 10 + (str[i++] - '0');
            if(res > INT_MAX)
                return flag ? INT_MIN : INT_MAX;
            if(res < INT_MIN)
                return flag ? INT_MIN : INT_MAX;
        }
        if(flag)
            res = -res;
        return static_cast<int>(res);
    }
```



20.二分查找



```C++
int binary_search(int a[], int size, int index) {
    if(size <= 0)
        return -1;
    
    int left = 0;
    int right = size - 1;
    while(left < right) {
        int mid = left + (right - left) / 2;
        if(a[mid] > index) {
            right = mid - 1;
        }
        else if(a[mid] < index) {
            left = mid + 1;
        }
        else {
            return mid;
        }
    }
    
    return -1;
}
```



21.单例



```C++
class Singleton {
  public:
    Singleton* get_instance() {
        if(instance == NULL) {
            mtx.lock();
            if(instance == NULL) {
                instance = new Singleton;
            }
            mtx.unlock();
        }
    }
  private:
    static Singleton *instance;
    static mutex mtx;
    
    Singleton();
    ~Singleton();
    Singleton(const Singleton &);
    Singleto &operator=(const Singleton &);
};

Singleton *Singleton::instance = NULL;
mutex Singleton::mtx;
```



22.LRU



```C++
class LRUCache
{
public:
    LRUCache(int capacity)
    {
        size = 0;
        this-> capacity = capacity;
    }

    int get(int key)
    {
        unordered_map<int, list<pair<int, int>>::iterator>::iterator it = m.find(key);
        if(it == m.end())///如果缓存中没有，返回-1
        {
            return -1;
        }
        cache.splice(cache.begin(), cache, it->second);///把it->second剪接到cache的开始位置
        return it->second->second;//返回list中该key对应的value
    }

    void put(int key, int value)
    {
        unordered_map<int, list<pair<int, int>>::iterator>::iterator it = m.find(key);
        if(it == m.end())//缓存中没有，直接插入到头部
        {
            pair<int, int> p(key, value);
            cache.insert(cache.begin(), p);
            m[key] = cache.begin();
            size ++;
        }
        else//缓存中存在，则修改其value值，并且设置为最近使用
        {
            it -> second -> second = value;
            cache.splice(cache.begin(), cache, it -> second);
        }
        if(size > capacity)//缓存超了，去掉尾，即最近最少使用的元素
        {
            pair<int, int> p = cache.back();
            m.erase(p.first);
            cache.pop_back();
            size--;
        }
    }
    int size;
    int capacity;
    unordered_map<int, list<pair<int, int>>::iterator> m;//map<key, key和value的迭代器>
    list<pair<int, int>> cache;//双向链表
}
```



23.字典树



```C++
class Trie
{
public:
    /** Initialize your data structure here. */
    Trie() {
        root = new Node();
    }

    /** Inserts a word into the trie. */
    void insert(string word) {
        if(word.size() <= 0)
            return;
        Node *current_node = root;
        const int len = word.size();
        for(int i = 0; i < len; i++)
        {
            //current_node中没有走向word[i]的路径
            if(current_node->node.find(word[i]) == current_node->node.end())
            {
                current_node->node[word[i]] = new Node();
            }
            //current_node指向下一级节点
            current_node = current_node->node[word[i]];
            current_node->path++;//路径值++
        }
        current_node->end_num++;
    }

    /** Returns if the word is in the trie. */
    bool search(string word) {
        if(word.size() <= 0)
            return false;
        Node *current_node = root;
        const int len = word.size();
        for(int i = 0; i < len; i++)
        {
            if(current_node->node.find(word[i]) == current_node->node.end())
                return false;//没有以这个节点为头节点的，直接返回，后边都不用找了
            current_node = current_node->node[word[i]];
        }
        return (current_node->end_num >= 1) ? true : false;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        if(prefix.size() <= 0)
            return false;
        Node *current_node = root;
        const int len = prefix.size();
        for(int i = 0; i < len; i++)
        {
            if(current_node->node.find(prefix[i]) == current_node->node.end())
                return false;//没有以这个节点为头节点的，直接返回，后边都不用找了
            current_node = current_node->node[prefix[i]];
        }
        return true;
    }

private:
        class Node
        {
            public:
                int end_num;    //代表多少个单词以这个结点结尾
                int path;       //代表多少个单词共用这个结点，统计前缀个数
                unordered_map<char, Node*> node;

                Node():end_num(0), path(0){}
        };

        Node *root;
};
```



24.实现string类

```C++
class my_string
{
private:
    char *m_data;
    int length;

public:
    my_string();                //默认构造函数
    my_string(const char *str); //普通构造函数
    my_string(const my_string &ms);//拷贝构造函数
    ~my_string();//析构函数

    my_string &operator=(const my_string &ms);//赋值函数
    char operator[](const unsigned int index);
};

my_string::my_string()
{
    m_data = new char[1];
    m_data[0] = '\0';
}

my_string::my_string(const char *str)
{
    if(str == NULL)
    {
        m_data = new char[0];
        m_data = '\0';
    }
    else
    {
        int tmp_len = strlen(str);
        m_data = new char[tmp_len + 1];
        length = tmp_len;
        memcpy(m_data, str, tmp_len);
    }
}

my_string::my_string(const my_string &ms)
{
    int tmp_len = strlen(ms.m_data);
    m_data = new char[tmp_len + 1];
    length = tmp_len;
    memcpy(m_data, ms.m_data, tmp_len);
}

my_string::~my_string()
{
    if(m_data != NULL)
    {
        delete[] m_data;
        m_data = NULL;
        length = 0;
    }
}

my_string &my_string::operator=(const my_string &ms)
{
    if(this == &ms)
        return *this;

    if(m_data != NULL)
    {
        delete[] m_data;
        m_data = NULL;
    }

    int tmp_len = strlen(ms.m_data);
    m_data = new char[tmp_len + 1];
    memcpy(m_data, ms.m_data, tmp_len);
    length = tmp_len;
    return *this;
}

char my_string::operator[](const unsigned int index)
{
    return m_data[index];
}
```





## 2.2 其他

### 2.21 删除链表中的节点 

- 问题描述
  - 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。
  - 
  - 说明:
  - 链表至少包含两个节点。
  - 链表中所有节点的值都是唯一的。
  - 给定的节点为非末尾节点并且一定是链表中的一个有效节点。
  - 不要从你的函数中返回任何结果。
  - 
  - 示例 1:
  - 输入: head = [4,5,1,9], node = 5
  - 输出: [4,1,9]
  - 解释: 给定你链表中值为5的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
- 问题思路
  - 因为链表至少有两个节点，所以不需要head节点就可以，只通过修改要删除的node节点的值和next指针即可。
- 编程实现

```
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val = node->next->val;
        node->next = node->next->next;
    }
};
```

### 2.22 两数之和

- 问题描述
  - 给定一个整数数组nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。
  - 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
  - 
  - 实例：
  - 给定 nums = [2, 7, 11, 15], target = 9
  - 因为 nums[0] + nums[1] = 2 + 7 = 9
  - 所以返回 [0, 1]
- 问题思路
  - 采取一边插入哈希表一边寻找一边在已经插入的哈希表中寻找的方式，每次都拿着即将插入哈希表的数字然后在哈希表中找是否存在剩下的那个函数。
  - unorder_map的效率比map高，在总体的时间复杂度O(n)
- 编程实现

```C++
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        unordered_map<int,int> m;
        for(int i = 0; i < nums.size(); i++)
        {
            int another = target - nums[i];
            if(m.find(another) != m.end())
            {
                res.push_back(m[another]);
                res.push_back(i);
                return res;
            }
            m[nums[i]] = i;
        }
        
        return res;
    }
```

### 2.23 两数相加

- 问题描述
  - 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。
  - 将这两个数相加起来，则会返回一个新的链表来表示它们的和。
  - 除了数字 0 之外，这两个数都不会以 0开头。
  - 
  - 实例：
  - 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
  - 输出：7 -> 0 -> 8
  - 原因：342 + 465 = 807
- 问题思路
  - 同位相加，注意进位和两个链表的长度，如果末尾进位的话需要在tail添加一个节点。
- 编程实现

```c++
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* res = new ListNode(0);
        ListNode* cur = res;
        int flag = 0;
        while(l1 || l2) {
            int num1 = l1 ? l1->val : 0;
            int num2 = l2 ? l2->val : 0;
            int sum = num1 + num2 + flag;
            flag = sum / 10;
            cur->next = new ListNode(sum % 10);
            cur = cur->next;
            if(l1) 
                l1 = l1->next;
            if(l2) 
                l2 = l2->next;
        }
        if(flag) 
            cur->next = new ListNode(flag);
        return res->next;
    }
```

### 2.24 无重复字符的最长子串

- 问题描述
  - 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
  - 
  - 示例1：
  - 输入: "abcabcbb"
  - 输出: 3
  - 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
  - 
  - 示例2：
  - 输入: "pwwkew"
  - 输出: 3
  - 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。注意，"pwke" 是一个子序列，不是子串。
- 问题思路
  - 滑动窗口 + 哈希表
  - 定义一个map存储<字符， 字符位置 + 1>,加一是表示从字符位置后一个开始不重复（如两个相邻字符重复等）。
  - 定义不重复子串的开始位置为 start，结束位置为 end，默认start = end = 0；
  - 随着 end 不断遍历向后，更新最大不重复长度，遇到与 [start, end] 区间内字符相同的情况（利用哈希表查询），将该字符作为key值的map中对应字符，更新其value值，并更新 start，此时 [start, end] 区间内不存在重复字符；
- 编程实现

```C++
    int lengthOfLongestSubstring(string s) {
        if(s.size() <= 0)
            return 0;
        
        unordered_map<char, int> m;
        int len = s.size();
        int res = 0;
        int start = 0;
        
        for(int end = 0; end < len; end++) {
            if(m.find(s[end]) != m.end()) { // 存在
                start = max(m[s[end]], start);
            }
            res = max(res, end - start + 1);
            m[s[end]] = end + 1;
        }
        
        return res;
    }
```

### 2.25 寻找两个有序数组的中位数

- 问题描述
  - 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。nums1 和 nums2 不会同时为空。
  - 请你找出这两个有序数组的中位数，
  - 要求算法的时间复杂度为 O(log(m + n))。
- 问题思路
  - 如果不要求时间负责度，则直接merge即可，时间复杂度为O(m+n)
  - 
  - 看到log的时间复杂度，使用二分的方式。
  - 假设两个数组的长度分别是m和n，若m+n是奇数，则找最中间的数即可，偶数的话需要求最中间两个数的平均值。为了不分情况讨论，可以：
  - 分别找第 (m+n+1) / 2 个和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。若 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。偶数则就是中间的两个数。
  - 
  - 然后定义一个函数去求第K个元素即可（分别求k=(m+n+1) / 2和 k=(m+n+2) / 2，然后取均值即可）；
  - 使用两个变量 start1 和 start2 分别标记两个数组开始的位置；
  - 当某一个数组的起始位置大于等于其数组长度时，说明该数组所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。
  - 当K=1时，那么我们只要比较两个数组的起始位置 start1 和 start2 上的数字就可以，取较小的即可。
  - 对于一般情况：需要分别在两个数组中找K/2个数字，
  - 如果某个数组没有第 K/2 个数字，那么我们就淘汰另一个数组的前 K/2 个数字即可。因为中位数肯定存在，所以不可能有两个数组都没有K/2个数字的情况。
  - 比较这两个数组的第 K/2 小的数字 midVal1 和 midVal2 的大小，如果第一个数组的第 K/2 个数字小的话，那么说明我们要找的数字肯定不在第一个数组中的前 K/2 个数字，所以我们可以将其淘汰，将第一个数组的起始位置向后移动 K/2 个，并且此时的K也自减去 K/2，反之，我们淘汰第二个数组中的前 K/2 个数字，并将第二个数组的起始位置向后移动 K/2 个，并且此时的K也自减去 K/2，调用递归继续。
- 编程实现

```C++
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size();
        int n = nums2.size();
        
        int left_mid = (m + n + 1) / 2;
        int right_mid = (m + n + 2) / 2;
        
        return (find_kTh_num(nums1, 0, nums2, 0, left_mid) + find_kTh_num(nums1, 0, nums2, 0, right_mid)) / 2.0;
    }
    
    int find_kTh_num(vector<int> &num1, int start1, vector<int> &num2, int start2, int k) {
        if(start1 >= num1.size())
            return num2[start2 + k - 1];//数组a中第k个的数在数组中的下标为a[k-1]
        if(start2 >= num2.size())
            return num1[start1 + k - 1];
        
        if(k == 1)
            return min(num1[start1], num2[start2]);
        
        int mid_val_1 = (num1.size() > (start1 + k / 2 - 1)) ? num1[start1 + k / 2 - 1] : INT_MAX;
        int mid_val_2 = (num2.size() > (start2 + k / 2 - 1)) ? num2[start2 + k / 2 - 1] : INT_MAX;
        
        if(mid_val_1 < mid_val_2)//舍弃数组1的前k/2
            return find_kTh_num(num1, start1 + k / 2, num2, start2, (k - k/2));
        else
            return find_kTh_num(num1, start1, num2, start2 + k / 2, (k - k/2));
        
    }
```

### 2.26 最长回文子串

- 问题描述
  - 给定一个字符串 s，找到 s 中最长的回文子串。
  - 
  - 实例：
  - 输入: "babad"
  - 输出: "bab"或者 "aba"
- 问题思路
  - 动态规划 或者 中心扩散法
  - 
  - 动态规划：二维数组dp，其中dp [left][right] = true 表示 字符串s[left, right]是回文串；
  - 当只有一个字符时，肯定是回文串，当两个字符时，若相等，也为回文串，当大于两个字符后：
  - 若s[left, right]是回文串，则s[left + 1, right - 1]也是回文串，即dp[i][j]由dp[i+1][j-1]决定;
  - dp数组是对称的，故只需保存上三角即可；
  - 通过状态
  - 状态方程为：
  - dp[i] [j] = true , i = j;
  - dp[i] [j] = (s[i] == s[j]), i + 1 = j;
  - dp[i] [j] = (dp[i + 1] [j - 1] && s[i] == s[j]), i + 1 < j
  - 
  - 中心扩散法：
- 编程实现

```C++
    string longestPalindrome(string s) {
        int n = s.size();
        if(n < 2)
            return s;
        
		vector<vector<bool> > state(n, vector<bool>(n, false));
		int start = 0, max_len = 1;
        /* 初始化状态矩阵 */
		for (int i = 0; i < n; i++) {
			state[i][i] = true;
			if (s[i] == s[i + 1]) {
				state[i][i + 1] = true;
				start = i;
				max_len = 2;
			}
		}
        
		for (int len = 3; len <= n; len++) {
			for (int i = 0; i <= n - len; i++) {
				int j = i + len - 1;
				if ((s[i] == s[j]) && (state[i + 1][j - 1])) {
					state[i][j] = true;
					start = i;
					max_len = len;
				}
			}
		}

		return s.substr(start, max_len);;
    }
```

### 2.27 整数反转

- 问题描述
  - 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
- 问题思路
  - 不考虑溢出的话，直接用整型计算即可。
  - 考虑溢出，使用long型，最终计算后计算是否溢出，如果溢出，返回0，否则返回类型转化即可。
- 编程实现

```C++
    int reverse(int x) {
        long rev = 0;
        while (x) {
            int pop = x % 10;
            x /= 10;
            rev = rev * 10 + pop;
        }
        return (rev > INT_MAX || rev < INT_MIN) ? 0 : static_cast<int>(rev);
    }
```

### 2.28 字符串转换整数 (atoi)

- 问题描述
  - 请你来实现一个 atoi 函数，使其能将字符串转换成整数。
  - 
  - 注意：
  - 该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
  - 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；但是两个连着的正负号认为是错误；
  - 假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
  - 在任何情况下，若函数不能进行有效的转换时，请返回 0。
  - 
  - 实例：
  - 输入: "42"
  - 输出: 42
  - 
  - 输入: "   -42"
  - 输出: -42
  - 
  - 输入: "4193 with words"
  - 输出: 4193
  - 
  - 输入: "words and 987"
  - 输出: 0
  - 
  - 输入: "-91283472332"
  - 输出: -2147483648/INT_MIN
- 问题思路
  - 先过滤掉开头非空格字符，然后对运算符正负号进行判断，之后对整数进行计算，计算时要随时判断是否越界，如果越界即时返回，不然计算越界。
- 编程实现

```
    int myAtoi(string str) {
        if(str.size() <= 0)
            return 0;
        
        int len = str.size();
        int i = 0;
        
        //找到第一个非空格的字符
        while(i < len) {
            if(str[i] != ' ')
                break;
            i++;
        }
        //如果全是空格
        if(i == len)
            return 0;
        
        //运算符正负号
        bool flag = false;
        if(str[i] == '-' && str[i+1] != '+') {
            flag = true;
            i++;
        }
        
        if(str[i] == '+' && str[i+1] != '-')
            i++;
        
        long long res = 0;
        while(i < len && str[i] >= '0' && str[i] <= '9') {
            res = res * 10 + (str[i++] - '0');
            if(res > INT_MAX)
                return flag ? INT_MIN : INT_MAX;
            if(res < INT_MIN)
                return flag ? INT_MIN : INT_MAX;
        }
        if(flag)
            res = -res;
        return static_cast<int>(res);
    }
```

### 2.19 正则表达式匹配

- 问题描述
  - 给你一个字符串s和一个字符规律p，请你来实现一个支持 '.'和'*'的正则表达式匹配。
  - '.' 匹配任意单个字符
  - '*' 匹配零个或多个前面的那一个元素
  - 所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。
  - 
  - 实例1：
  - 输入:s = "aa" p = "a"
  - 输出: false
  - 
  - 实例2：
  - 输入:s = "aa" p = "a*"
  - 输出: true
  - 
  - 实例3：
  - 输入:s = "aab"    p = "c * a * b"
  - 输出：true
- 问题思路
  - 思路一：正常匹配，对于正常的字符和.字符都匹配，对 * 的处理，有三种情况
  - a * 完全不匹配，即需要跳过 * 以及 * 前面的字母；
  - a* 只匹配一个字母
  - a* 匹配多个递归判别。
  - 
  - 思路二： 因为具有递归性质、重叠子问题的性质，所以可以用动态规划来考虑。
  - dp[i][j] 表示 s 前 i 个和 p 前 j 个匹配，注意这里假设字符串前面都有一个空串，并且全部初始化为false；
  - 
  - 1.IF p[j] ≠ '*'AND (p[j] = s[i] OR p[j] = '.')，dp[i][j] = dp[i - 1][j - 1]；
  - 2.IF p[j] = '*' AND p[j - 1] ≠ s[i], dp[i][j] = dp[i][j - 2]
  - 3.IF p[j] = '*' AND (p[j - 1] = s[i] OR p[j - 1] = '.'), dp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i][j - 2]
  - 注：对于2和3的状态方程，假设p[j] = *,p[j - 1]=a,则
  - 对于情况2，dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty
  - 对于情况3，dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a
  - dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a
  - dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty
- 编程实现

```
    bool isMatch(string s, string p) {
        int lenS = s.length();
        int lenP = p.length();
        
        if(lenP == 0)
            return lenS == 0 ? true : false;
        else if(lenP == 1) {
            if(lenS == 0)
                return false;
            else if(lenS != 0 && (s[0] == p[0] || p[0] == '.'))
                return isMatch(s.substr(1), p.substr(1));
            else
                return false;
                
        }
        else {
            if(p[1] == '*') {
                while(s.length() != 0 && (p[0] == s[0] || p[0] == '.')) {
                    if (isMatch(s, p.substr(2)))
                        return true;
                    else {
                        s = s.substr(1);
                    }
                }
                
                return isMatch(s, p.substr(2));
            }
            else {
                if (s.length() != 0 && (p[0] == s[0] || p[0] == '.'))
                    return isMatch(s.substr(1), p.substr(1));
                else 
                    return false;
            }
        }
    }
    
    //动态规划解法
    bool isMatch(string s, string p){
        int len_S = s.length();
        int len_P = p.length();

        if(len_P && p[0] == '*')
            return false;

        vector<vector<bool> > dp(len_S + 1, vector<bool>(len_P + 1, false));
        dp[0][0] = true;

        for(int i = 1; i <= len_P; i++) {
            if(p[i - 1] == '*')
                dp[0][i] = dp[0][i - 1] || dp[0][i - 2];//由于每个字符串前边都加了一个空字符，所以注意下标对应
        }

        for(int i = 1; i <= len_S; i++) {
            for(int j = 1; j <= len_P; j++) {
                    if(p[j - 1] != '*' && (p[j - 1] == s[i - 1] || p[j - 1] == '.') ) {
                        dp[i][j] = dp[i - 1][j - 1];
                    }
                    else if(p[j - 1] == '*') {
                        if(p[j - 2] == s[i - 1] || p[j - 2] == '.')
                            dp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i][j - 2];
                        else
                            dp[i][j] = dp[i][j - 2];
                    }
            }
        }

        return dp[len_S][len_P];
	}
```

### 2.20 乘最多水的容器  

- 问题描述
  - 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。
  - 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
  - 
  - 示例:
  - 输入: [1,8,6,2,5,4,8,3,7]
  - 输出: 49
  - 解释：数组第二个8和最后一个7构成的7 * 7的数组
- 问题思路
  - 暴力法：遇到数组大小特别大时，会超时(测试用例数组长度15000时，超时)
  - 双指针法：设置两指针left,right分别位于容器壁两端，逐渐向中间收缩并记录最大值；
  - 水槽的高度由两板中的短板决定，每次收缩，都会导致水槽底边宽度-1；
  - 因此，若想找到比当前最大值更大的水槽，那么水槽的短板高必须要高于上一个水槽短板高，而只有向内移动短板，有可能达成这一条件。
  - 
  - 证明：放弃了短线段不变, 长线段向内收缩的那一部分容器, 但是在这一容器中说不定就有盛水最多的可能, 是如何确定不会出现这种情况呢? --- 即双指针法的正确性验证。
  - 可以画一个树，包含所有遍历可能，可以发现，每次移动指针放弃的那一部分容器，其面积一直小于双指针选择的路径。
- 编程实现

```
    int maxArea(vector<int>& height) {
        if(height.size() <= 0)
            return 0;
        
        int res = 0;
        int len = height.size();
        int left = 0, right = len - 1;
        while(left < right) {
            res = max(res, min(height[left], height[right]) * (right - left));
            
            if(height[left] < height[right])
                left++;
            else
                right--;
        }
        
        return res;
    }
```

### 2.21 罗马数字转整数

- 问题描述
  - 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
  - 字符          数值
  - I             1
  - V             5
  - X             10
  - L             50
  - C             100
  - D             500
  - M             1000
  - 六种特殊的规则情况：
  - I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。
  - X可以放在L(50) 和C(100) 的左边，来表示 40 和90。
  - C可以放在D(500) 和M(1000) 的左边，来表示400 和900。
  - 
  - 实例：
  - 输入："III"   输出：3
  - 
  - 输入: "LVIII" 输出: 58
  - 
  - 输入: "MCMXCIV"   输出: 1994
- 问题思路
  - 注意判断即可
- 编程实现

```
    int romanToInt(string s) {
        int res=0;
        for(int i=0;i<s.size();i++){
            if(s[i]=='I'){
                if(i + 1 < s.size() && (s[i+1]=='X' || s[i+1]=='V'))
                    res -= 1;
                else 
                    res += 1;
            }
            else if(s[i]=='V') 
                res += 5;
            else if(s[i]=='X'){
                if(i+1 < s.size() && (s[i+1]=='L' ||s[i+1]=='C'))
                    res -= 10;
                else 
                    res += 10;
            }
            else if(s[i]=='L') 
                res += 50;
            else if(s[i]=='C'){
                if(i+1<s.size() && (s[i+1]=='D' ||s[i+1]=='M'))
                    res -= 100;
                else 
                    res += 100;
            }
            else if(s[i]=='D') 
                res += 500;
            else if(s[i]=='M') 
                res += 1000;
        }
        return res;
    }
```

### 2.22 最长公共前缀

- 问题描述
  - 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串""。
  - 示例1:
  - 输入: ["flower","flow","flight"]
  - 输出: "fl"
  - 示例2:
  - 输入: ["dog","racecar","car"]
  - 输出: ""
- 问题思路
  - 最长公共前缀不会超过最小的字符串 逐个字符判断是否相等。
  - 先遍历字符串的长度，记录最短长度k；
  - 然后每次只在最短长度k内遍历即可，遍历所有字符串的前k位，字符串逐个字符判断是否相等，
- 编程实现

```
    string longestCommonPrefix(vector<string>& strs) {
        if (strs.size()==0) return ""; 
        int min_len = INT_MAX;
        string res;
        
        for(int i = 0; i < strs.size(); i++)
        {
            int tmp = strs[i].length();
            min_len = min(min_len, tmp);
        }
        
        for (int i = 0; i < min_len; i++) {
           for(int k = 0; k < strs.size() - 1; k++) {
               if(strs[k][i] == strs[k + 1][i])
                   continue;
               else
                   return res;
           }
            res = res + strs[0][i];
        }
        return res;
    }
```

### 2.23 三数之和

- 问题描述
  - 给定一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？找出所有满足条件且不重复的三元组。
  - 
  - 实例：
  - 输入： nums = [-1, 0, 1, 2, -1, -4]
  - 输出： [[-1, 0, 1], [-1, -1, 2]]
- 问题思路
  - 先将给定 nums 排序；
  - 固定三个数字中最左数字的指针 k，遍历 k 找到每个k对应的所有满足nums[k] + nums[i] + nums[j] == 0的 i,j 组合。即每指向新的 nums[k]，都通过双指针法找到所有和为 00 的 nums[i]，nums[j] 并记录：
  - 当 nums[k] > 0 时直接跳出，因为 j > i > k，即三个数字都大于 00，在此k之后不可能找到组合了；
  - 当 k > 0且nums[k] == nums[k - 1]时跳过此数字k，因为 nums[k - 1] 的所有组合已经被加入到结果中，本次搜索只会搜索到重复组合。
  - i，j 分设在数组 [k, len(nums)] 两端，根据 sum 与 00 的大小关系交替向中间逼近，如果遇到等于 00 的组合则加入 res 中，
  - 需要注意：移动 i，j 需要跳过所有重复值，以避免重复答案被计入 res。
- 编程实现

```
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        if(nums.size() <= 0)
            return res;
        sort(nums.begin(), nums.end());
        
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] > 0)//最左边大于0，则三个值相加肯定大于0
                break;
            if(i > 0 && nums[i] == nums[i - 1])//去重
                continue;
            
            int index = nums[i];
            int left = i + 1;
            int right = nums.size() - 1;
            while(left < right) {
                int sum = nums[left] + nums[right] + index;
                if(sum == 0) {
                    res.push_back({index, nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1]) // 去重
                        left++; 
                    while (left < right && nums[right] == nums[right - 1])
                        right--; // 去重
                    left++;
                    right--;
                }
                else if(sum < 0) {
                    left++;
                }
                else {
                    right--;
                }
            }
        }
        return res;
    }
```

### 2.24 电话号码的字母组合

- 问题描述
  - 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
  - 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
  - 2-abc, 3-def, 4-ghi, 5-jkl, 6-mno, 7-pqrs, 8-tuv, 9-wxyz
- 问题思路
  - 使用BFS（广度优先搜索）+ 哈希表完成
  - 递归，递归过程中保存满足情况的结果
- 编程实现

```
    vector<string> letterCombinations(string digits) {
        unordered_map<char, string> m{{'2', "abc"}, {'3', "def"}, {'4', "ghi"}, {'5',"jkl"}, {'6',"mno"}, {'7',"pqrs"}, {'8',"tuv"}, {'9',"wxyz"}};
        vector<string> res;
        if(digits.length() <= 0)
            return res;
        
        bfs(res, "", digits, m, 0);
        return res;
    }
    
    void bfs(vector<string> &res, string ori, string dest, unordered_map<char, string> m, int index) {
        if(ori.length() == dest.length()) {
            res.push_back(ori);
            return;
        }
        
        string tmp = m[dest[index]];
        for(char w : tmp) {
            ori += w;
            bfs(res, ori, dest, m, index + 1);
            ori = ori.substr(0, ori.length() - 1);
        }
        return;
    }
```

### 2.25 删除链表的倒数第N个节点

- 问题描述
  - 给定一个链表，删除链表的倒数第n个节点，并且返回链表的头结点。
  - 示例：
  - 给定一个链表: 1->2->3->4->5, 和 n = 2.
  - 当删除了倒数第二个节点后，链表变为 1->2->3->5.
  - 
  - 要求：使用一趟扫描实现。
- 问题思路
  - 双指针，快指针先走n步，然后快慢指针一起移动，当快指针移动到链表尾部的时候，慢指针的next就是需要删除的节点。
- 编程实现

```
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(head == NULL)
            return head;
        ListNode *fast = head;
        ListNode *slow = head;
        for(int i = 0; i < n; i++) {
            if(fast == NULL)
                return head;
            fast = fast->next;
        }
        if(fast == NULL)
            return head->next;
        
        while(fast->next) {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return head;
    }
```

### 2.26 有效的括号

- 问题描述
  - 给定一个只包括 '('，')'，'{'，'}'，'['，']'的字符串，判断字符串是否有效。
  - 有效字符串需满足：
  - 左括号必须用相同类型的右括号闭合。
  - 左括号必须以正确的顺序闭合。
  - 注意空字符串可被认为是有效字符串。
- 问题思路
  - 使用栈
  - 左括号入栈，栈顶为对应右括号则出栈，最后判断栈是否为空，若为空，则说明是有效字符串
- 编程实现

```
    bool isValid(string s) {
        if(s.empty())
            return true;
        if(s.length() == 1)
            return false;
        
        stack<char> sa;
        for(int i = 0; i < s.length(); i++) {
            if(sa.empty())
                sa.push(s[i]);
            else {
                char tmp = sa.top();
                if(tmp == ')' || tmp == '}' || tmp == ']')
                    return false;
                if(s[i] == '(' || s[i] == '{' || s[i] == '[')
                    sa.push(s[i]);
                else {
                    if((s[i] == ')' && tmp == '(') || 
                      (s[i] == ']' && tmp == '[') || 
                      (s[i] == '}' && tmp == '{')) {
                        sa.pop();
                    }
                    else
                        return false;
                }
            }
        }
        
        if(sa.empty())
            return true;
        else
            return false;
    }
```

### 2.27 合并两个有序链表

- 问题描述
  - 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
  - 示例：
  - 输入：1->2->4, 1->3->4
  - 输出：1->1->2->3->4->4
- 问题思路
  - 递归 + 归并的思路
- 编程实现

```
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == NULL) {
             return l2;
        }
        else if (l2 == NULL) {
            return l1;
        }
        else {
            if (l1->val <= l2->val) {
                l1->next = mergeTwoLists(l1->next, l2);
                return l1;
            }
            else {
                l2->next = mergeTwoLists(l1, l2->next);
                return l2;
            }
        }
    }
```

### 2.28 括号生成

- 问题描述
  - 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。
  - 例如，给出n = 3，生成结果为：
  - [
  - "((()))",
  - "(()())",
  - "(())()",
  - "()(())",
  - "()()()"
  - ]
- 问题思路
  - 回溯法
  - 知道序列仍然保持有效时才添加 '(' or ')'。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，
  - 如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。
- 编程实现

```C++
    vector<string> generateParenthesis(int n) {
        vector<string> res;
        if(n <= 0)
            return res;
        generateParenthesisCore(res, "", 0, 0, n);
        return res;
    }
    
    void generateParenthesisCore(vector<string> &res, string cur, int open, int close, int n) {
        if(cur.length() == n * 2)
        {
            res.push_back(cur);
            return;
        }
        
        if (open < n)
            generateParenthesisCore(res, cur + "(", open + 1, close, n);
        if (close < open)
            generateParenthesisCore(res, cur + ")", open, close + 1, n);
    }
```

### 2.29 合并K个排序链表

- 问题描述
  - 合并 k 个排序链表，返回合并后的排序链表。
  - 示例:
  - 输入:[[1,4,5],[1,3,4],[2,6]]
  - 输出: 1->1->2->3->4->4->5->6
- 问题思路
  - 分治法，链表两两合并，然后再整体合并
  - 时间复杂度： O(Nlogk) ，其中 k 是链表的数目。我们可以在 O(n) 的时间内合并两个有序链表，其中 n 是两个链表中的总节点数。
  - 然后两两合并的时间O(logk)
- 编程实现

```C++
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size() <= 0)
            return NULL;
        ListNode *res = merge(lists, 0, lists.size() - 1);
        return res;
    }
    
    ListNode* merge(vector<ListNode*>& lists, int left, int right) {
        if(left == right)
            return lists[left];
        
        int mid = left + (right - left) / 2;
        ListNode *list1 = merge(lists, left, mid);
        ListNode *list2 = merge(lists, mid + 1, right);
        
        return merge_twoList(list1, list2);
    }
    
    ListNode* merge_twoList(ListNode *l1, ListNode *l2) {
        if(l1 == NULL)
            return l2;
        if(l2 == NULL)
            return l1;
        
        if(l1->val <= l2->val) {
            l1->next = merge_twoList(l1->next, l2);
            return l1;
        }
        else {
            l2->next = merge_twoList(l1, l2->next);
            return l2;
        }
    }
```

### 2.30 

- 问题描述
- 问题思路
- 编程实现

```

```

## 