# 一、基本概念

## 1.主键、外键、超键、候选键

- **超键**：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。

- **候选键**：是最小超键，即没有冗余元素的超键。

- **主键**：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。

- **外键**：在一个表中存在的另一个表的主键称此表的外键。



## 2.为什么用自增列作为主键

- **数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。**这就**要求同一个叶子节点内**（大小为一个内存页或磁盘页）的**各条数据记录按主键顺序存放**，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）

- 如果表**使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。**

- 如果**使用非自增主键**，由于**每次插入主键的值近似于随机**，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了**将新记录插到合适位置而移动数据**，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时**频繁的移动、分页操作造成了大量的碎片**，得到了不够紧凑的索引结构。
- 如果定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。



## 3.什么是存储过程？用什么来调用？

- **存储过程是一个预编译的SQL语句**，优点是允许模块化的设计，就是说**只需创建一次，以后在该程序中就可以调用多次。**
- 如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。
- **调用方式**：
  - **可以用一个命令对象来调用存储过程。**
  - **可以供外部程序调用。**



## 4.存储过程的优缺点？

- 优点：
  - 存储过程是**预编译过的，执行效率高。**
  - 存储过程的**代码直接存放于数据库中**，**通过存储过程名直接调用，减少网络通讯。**
  - **安全性高**，**执行**存储过程**需要有一定权限**的用户。
  - 存储过程**可以重复使用**，可减少数据库开发人员的工作量。

- 缺点：移植性差



## 5.触发器的作用？

- **触发器是一种特殊的存储过程**，主要是**通过事件来触发而被执行的。**
- **触发器可以强化约束，来维护数据的完整性和一致性**，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。
- 如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。



## 6.存储过程与函数的区别

- **函数有返回一个变量（返回值或者表对象）的限制**，而**存储过程可以返回多个**，如返回参数等。
- 函数是可以嵌入在sql中使用的,可以在select中调用，而存储过程不行。**存储过程一般是作为一个独立的部分来执行（EXEC执行）**，而**函数可以作为查询语句的一个部分来调用（SELECT调用）**，由于函**数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。** 
- **函数限制比较多，比如不能用临时表，只能用表变量。**
- 



## 7.什么叫视图？游标是什么？

- **视图**：是一种**虚拟的表**，**具有和物理表相同的功能**。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。**对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。**
- **游标**：是**对查询出来的结果集作为一个单元来有效的处理。**游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。**可以对结果集当前行做修改**。一般不使用游标，但是**需要逐条处理数据的时候**，游标显得十分重要。



## 8.视图的优缺点

- 优点：
  - 对数据库的访问，因为**视图可以有选择性的选取数据库里的一部分**。
  - 用户通过**简单的查询可以从复杂查询中得到结果**。
  - **维护数据的独立性**，试图可从多个表检索数据。
  - **对于相同的数据可产生不同的视图**。

- 缺点：
  - **性能**：**查询视图时，必须把视图的查询转化成对基本表的查询**，如果这个视图是由一个复杂的多表查询所定义，就无法更改数据



## 9.drop、truncate、 delete区别

- **drop**：直接删掉表。

- **truncate**：删除表中数据，再插入时自增长id又从1开始。

- **delete**：删除表中数据，可以加where字句。
- 区别：
  - **DELETE语句执行删除的过程是每次从表中删除一行，可以回滚恢复，如果删除时会触发相关触发器。**
  - **TRUNCATE 一次性地从表中删除所有的数据，不能恢复吗，不会触发触发器。**
  - 表被**TRUNCATE** 后，这个**表和索引所占用的空间会恢复到初始大小**。**drop语句将表所占用的空间全释放掉。**
  - **TRUNCATE 只能对TABLE**；**DELETE可以是table和view**；
  -  **truncate与不带where的delete ：只删除数据，而不删除表的结构**（定义）
  - **drop语句将删除表的结构被依赖的约束,触发器，索引;依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。**
  - **Truncate速度快,效率高,**因为DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。
  - 对于**有外键约束引用的表，不能使用 TRUNCATE** TABLE，而应使用不带 WHERE 子句的 DELETE 语句。



## 10.什么是临时表，临时表什么时候删除?

- 临时表可以手动删除：DROP TEMPORARY TABLE IF EXISTS temp_tb;
- 临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。
- 不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。
- 创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，
- 如：

```sql
CREATE TEMPORARY TABLE tmp_table (
NAME VARCHAR (10) NOT NULL,
time date NOT NULL
);

select * from tmp_table;
```



## 11.非关系型数据库和关系型数据库区别，优势比较?

- 非关系型数据库的优势：
  - NOSQL是基于键值对的，不需要经过SQL层的解析，所以性能非常高。
  - 同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

- 关系型数据库的优势：
  - 复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
  - 事务支持：使得对于安全性能很高的数据访问要求得以实现。



## 12.数据库范式，根据某个场景设计数据表?

- 第一范式:(确保每列保持原子性)所有字段值都是不可分解的原子值。

- 第二范式:(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

- 第三范式:(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。

- BCNF:符合3NF，并且，主属性不依赖于主属性。



## 13.什么是 内连接、外连接、交叉连接、笛卡尔积等?

- **内连接: 只连接匹配的行**
- **左外连接: 包含左边表的全部行**（不管右边的表中是否存在与它们匹配的行），**以及右边表中全部匹配的行**
- **右外连接: 包含右边表的全部行**（不管左边的表中是否存在与它们匹配的行），**以及左边表中全部匹配的行**
  - 例如左外链接：SELECT a.,b. FROM luntan LEFT JOIN usertable as b ON a.username=b.username
  - 例如右外连接：SELECT a.,b. FROM city as a FULL OUTER JOIN user as b ON a.username=b.username
- **全外连接**: **包含左、右两个表的全部行**，不管另外一边的表中是否存在与它们匹配的行。
- **交叉连接**: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是**直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配**
  - 例如：SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type



## 14.varchar和char的使用场景?

- **char的长度是不可变的，而varchar的长度是可变的。**定义一个char[10]和varchar[10]。如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。

- **char的存取数度还是要比varchar要快得多**，因为其长度固定，方便程序的存储与查找。char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是**以空间换取时间效率**。

- **char的存储方式是：对英文字符（ASCII）占用1个字节**，**对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。**

- 两者的存储数据**都非unicode的字符数据**。



## 15.SQL语言四大分类：

- 数据查询语言DQL：数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：

- 数据操纵语言DML：插入：INSERT、更新：UPDATE、删除：DELETE、修改表ALTER

- 数据定义语言DDL：创建数据库中的各种对象-----表、视图、索引，CREATE TABLE/VIEW/INDEX/等

- 数据控制语言DCL： GRANT：授权、ROLLBACK 回滚、 COMMIT：提交。



## 16.like %和-的区别

- **%百分号通配符:**表示任何字符出现任意次数(可以是0次).

- **_下划线通配符:**表示只能匹配单个字符,不能多也不能少,就是一个字符.

- **like操作符**: LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.



## **17.count(*)、count(1)、count(column)的区别**

- **count(*)**：对行的数目进行计算,包含NULL

- **count(column)**：对特定的列的值具有的行数进行计算,不包含NULL值。

- **count(1)**：用法和count(*)的结果是一样的。只扫描主键。

- 性能问题:
  - 任何情况下SELECT COUNT(*) FROM tablename是最优选择;*
  - 尽量减少SELECT COUNT() FROM tablename WHERE COL = ‘value’ 这种查询;
  - 杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 = ‘value’ 的出现。

- 如果表没有主键,那么count(1)比count(*)快。

- 如果有主键,那么count(主键,联合主键)比count(*)快。

- 如果表只有一个字段,count(*)最快。



# 二、索引

## 1.什么是索引？

- **数据库索引**：是数据库管理系统中**一个排序的数据结构**，索引的实现通常使用B树及其变种B+树。
- 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，**这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法**。这种数据结构，就是索引。



## 2.索引的作用？

- **协助快速查询、更新数据库表中数据**。
- 为表设置索引要付出代价的：
  - 一是增加了数据库的存储空间
  - 二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。



## 3.索引的优缺点？

- 优点：
  - 创建索引可以大大**提高系统的性能**
  - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
  - 可以大大**加快数据的检索速度**，这也是创建索引的最主要的原因。
  - 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
  - 在使用分组和排序子句进行数据检索时，同样可以**显著减少查询中分组和排序的时间**。
  - 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

- 缺点：
  - **创建索引和维护索引要耗费时间**，这种时间随着数据量的增加而增加。
  - 索引需要占物理空间，除了数据表占数据空间之外，**每一个索引还要占一定的物理空间**，如果要建立聚簇索引，那么需要的空间就会更大。
  - 当**对表中的数据进行增加、删除和修改的时候，索引也要动态的维护**，这样就降低了数据的维护速度。



## 4.哪些列适合建立索引、哪些不适合建索引？

- 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。
- 一般来说，应该在这些列上创建索引：
  - 在经常需要搜索的列上，可以加快搜索的速度；
  - 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
  - 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
  - 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
  - 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
  - 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。

- 对于有些列不应该创建索引：
  - 对于那些在查询中很少使用或者参考的列不应该创建索引。
  - 对于那些只有很少数据值的列也不应该增加索引。
  - 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
  - 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

- 什么样的字段适合建索引：唯一、不为空、经常被查询的字段



## 5.MySQL B+Tree索引

- B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;
- 常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。
- B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。
- 在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。



## 6.B树和B+树的区别

- **B树：平衡多路搜索树**（每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素），**每个节点都存储key和data**，所有节点组成这棵树，并且**叶子节点指针为null**，叶子结点不包含任何关键字信息。
  - B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；
  - B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得**B树在特定数据重复多次查询的场景中更加高效**。
- **B+树**：**所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针**，且**叶子结点本身**依关键字的大小**自小而大的顺序链接**，所有的非终端结点可以看成是索引部分，**结点中仅含有其子树根结点中最大（或最小）关键字**。 



## 7.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？

- B+的磁盘读写代价更低：
  - B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

- B+tree的查询效率更加稳定
  - 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

- B+树的数据遍历更方便
  - B+树只要遍历叶子节点就可以实现整棵树的遍历，而B树不支持这样的操作（或者说效率太低），而且在数据库中基于范围的查询是非常频繁的，所以数据库索引基本采用B+树



## 8.聚集索引和非聚集索引区别?

- **聚集索引**:
  - **聚集索引表记录的排列顺序和索引的排列顺序一致**，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的**缺点就是修改慢**，因为为了保证表中记录的物理和索引顺序一致，**在记录插入的时候，会对数据页重新排序。**
  - 聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。

- **非聚集索引**：
  - **非聚集索引指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致**，**两种索引都采用B+树结构**，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。**非聚集索引层次多，不会造成数据重排。**
  - 非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。
- **根本区别：聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。**



# 三、事务

## 1.什么是事务？

- **事务是对数据库中一系列操作进行统一的回滚或者提交的操作**，主要用来保证数据的完整性和一致性。



## 2.事务四大特性（ACID）：原子性、一致性、隔离性、持久性

- **原子性**:原子性是指**事务包含的所有操作要么全部成功，要么全部失败回滚**，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

- **一致性:事务开始前和结束后，数据库的完整性约束没有被破坏**。比如A向B转账，不可能A扣了钱，B却没收到。

- **隔离性**:隔离性是当**多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。**同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

- **持久性**:持久性是指**一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的**，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。



## 3.事务的并发?

- **事务的并发问题**
- **丢失更新**：撤销一个事务时，把其他事务已提交的更新数据覆盖，如A和B事务并发执行，A事务执行更新后，提交；B事务在A事务更新后，B事务结束前也做了对该行数据的更新操作，然后回滚，则两次更新操作都丢失了。
  - **脏读**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
  
- **不可重复读**：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。
  - **幻读**：一个事务读到另一个事务已提交的新插入的数据。
  - **可重复读**：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象
  
- 例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。



## 4.事务的隔离级别

- 事务的四种隔离级别：
  - **读未提交**：一个事务在执行过程中可以看到其他事务没有提交的新插入的记录，而且能看到其他事务没有提交的对已有记录的更新。
    - 不添加共享锁。所以其它transaction B可以在transaction A对记录的读取过程中修改同一记录，可能会导致A读取的数据是一个被破坏的或者说不完整不正确的数据。
    - 在transaction A中可以读取到transaction B（未提交）中修改的数据。比如transaction B对R记录修改了，但未提交。此时，在transaction A中读取R记录，读出的是被B修改过的数据。
  - **读已提交**：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且能看到其他事务已经提交的对已有记录的更新。
    - 在transaction A中读取数据时对记录添加共享锁，但读取结束立即释放。其它transaction B对这个记录的试图修改会一直等待直到A中的读取过程结束，而不需要整个transaction A的结束。所以，在transaction A的不同阶段对同一记录的读取结果可能是不同的。
  - **可重复读**：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他其他事务对已有记录的更新。
    - 对于读出的记录，添加共享锁直到transaction A结束。其它transaction B对这个记录的试图修改会一直等待直到transaction A结束。
  - **串行化**：一个事务在执行过程中完全看不到其他事务对数据库所做的更新，即事务执行的时候不允许别的事务并发执行。事务串行化执行，事务只能一个接着一个地执行，而不能并发执行
    - 添加范围锁（比如表锁，页锁等），直到transaction A结束。以此阻止其它transaction B对此范围内的insert，update等操作。
- MySQL默认的事务隔离级别为可重复读、Oracle 支持的 2 种事务隔离级别：读已提交 , 串行化

- MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行

- 事务隔离级别：
  - 读未提交时，写数据只会锁住相应的行。
  - 可重复读时，写数据会锁住整张表。
  - 串行化时，读写数据都会锁住整张表。
- 读未提交：会丢失更新、会脏读、会非重复读、会覆盖更新、会幻读；
- 读已提交：不会丢失更新、不会脏读、会非重复读、会覆盖更新、会幻读；
- 可重复读：不会丢失更新、不会脏读、不会非重读读、不会覆盖更新、会幻读；
- 串行化：不会丢失更新、不会脏读、不会非重读读、不会覆盖更新、不会幻读；



## 5.什么是嵌套事务？

- **嵌套：子事务套在父事务中执行**，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，然后执行子事务，这个子事务的执行也算是父事务的一部分，子事务执行结束，父事务继续执行。
- 如果子事务回滚，会发生什么？父事务会回滚到进入子事务前建立的回滚点，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。

- 如果父事务回滚，会发生什么？父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：

- 事务的提交，是什么情况？是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。





# 四、数据库锁

## 1.mysql锁的种类？死锁？

- **MySQL有三种锁的级别：**页级、表级、行级。

  - **表级锁：**开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。

  - **行级锁：**开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

  - **页面锁：**开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

  - ****

- **什么情况下会造成死锁?**

- **死锁:** 是**指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象**,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程。

- **表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。**

- **死锁的关键在于：**两个(或以上)的Session加锁的顺序不一致。那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。

- **死锁的解决办法?**

- 1.查出的线程杀死 kill：SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;

- 2.设置锁的超时时间：Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。

-  3.指定获取锁的顺序



## 2.悲观锁和乐观锁？

- **悲观锁:**
  - **悲观锁特点:**先获取锁，再进行业务操作。
  - 即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。
  - 通常所说的**“一锁二查三更新”即指的是使用悲观锁。**
  - 通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。
  - 当数据库执行select ... for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。
  - select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。
- **乐观锁**：
  - **乐观锁的特点先进行业务操作，不到万不得已不去拿锁。**
  - 即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。表加版本号或者时间戳，是数据库实现乐观锁的一种方式。
  - 它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。
  - 在提交数据更新之前，每个事务会先检查在该事务读取数据后，如果乐观锁获取成功，操作完成。如果乐观锁获取失败，回滚并重试。
- **总结：**
  - 悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法。
  - **响应速度：** 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。
  - **冲突频率：** 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。
  - **重试代价：** 如果重试代价大，建议采用悲观锁。



# 五、存储引擎

## 1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?

- MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。
- InnoDB和MyISAM的区别表现在：
  - **InnoDB支持事务，MyISAM不支持。**事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。
  - **MyISAM适合查询以及插入为主的应用。**
  - **InnoDB适合频繁修改以及涉及到安全性较高的应用。**
  - **InnoDB支持外键，MyISAM不支持。**
  - 从MySQL5.5.5以后，InnoDB是默认引擎。
  - InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表。
  - 对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。
  - DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢。MyISAM则会重建表。
  - InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like '%lee%'。

- MEMORY存储引擎：使用存储在内存中的内容来创建表，而且数据全部放在内存中。MEMORY默认使用哈希索引。基于MEMORY的表的生命周期很短，一般是一次性的。



## 3.MyISAM与InnoDB在事务、锁级别，各自的适用场景?

- **事务处理上**方面
  - **MyISAM：强调的是性能**，每次**查询具有原子性**,其执行数度比InnoDB类型更快，但是**不提供事务支持**。
  - **InnoDB**：**提供事务支持事务，外部键等**功能。 **具有事务、回滚**和崩溃修复能力的事务安全型表。

- **锁级别**
  - **MyISAM**：**只支持表级锁**，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。
  - **InnoDB：支持事务和行级锁**，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。



# 六、SQL语句

## 1.SQL查询语句的执行先后顺序?

- 顺序依次为 select--from--where--group by--having--order by

- 其中select和from是必须的，其他关键词是可选的，
- 执行顺序与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行
  - from:需要从哪个数据表检索数据
  - where:过滤表中数据的条件
  - group by:如何将上面过滤出的数据分组
  - having:对上面已经分组的数据进行过滤的条件
  - select:查看结果集中的哪个列，或列的计算结果
  - order by :按照什么样的顺序来查看返回的数据



- **from后面的表关联，是自右向左解析，而where条件的解析顺序是自下而上的**。也就是说，在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边 （用小表去匹配大表）

- 使用explain优化sql和索引。



# 七、其他

## 1.主从复制

- 方式：**同步复制**（master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回）、**异步复制**（master只需要完成自己的数据库操作）、**半同步复制**(master只保证slaves中的一个操作成功，就返回，其他slave不管)
- master和slaves同时进行写操作，且slave无法通知master时，这时slave不应该进行写操作。
- 主从复制中，可以有N个slave,这些slave不能进行写操作，其作用是：实现数据备份，异地灾容，如果master挂了，由slaves提升为master；还可以实现负载分担，写操作发向master，读操作发向slaves进行操作。
- 多个slaves时，由应用程序决定怎么从slaves选择一个来执行select。
- master每产生一个事件，有N个slave,要进行N次发送，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,...的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。



## 2.数据库的高并发

- 分库分表、分布式、增加二级缓存、读写分离、数据库集群



## 3.崩溃恢复

- **Undo Log:**MySQL数据库InnoDB存储引擎中，还用了Undo Log来实现多版本并发控制，
- 逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。
- 当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。
- **缺陷：**每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。
- **Redo Log:**
- redo log在数据库重启恢复的时候被使用，因为其属于物理日志的特性，恢复速度远快于逻辑日志。redo log就是存储了数据被修改后的值。当我们提交一个事务时，InnoDB会先去把要修改的数据写入日志，然后再去修改缓冲池里面的真正数据页。
- 当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。

