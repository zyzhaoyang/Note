# 一、语言基础

## 1.声明和定义

- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；

- 定义要在定义的地方为其分配存储空间。

- 相同变量可以再多处声明（外部变量extern），但只能在一处定义。

  

## 2.const

### 作用

- 修饰变量，说明该变量不可以被改变；const在指针星号左边；
- 修饰指针，分为指向常量的指针和指针常量；const在指针星号右边；
- 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
- 修饰成员函数，说明该成员函数内不能修改成员变量。

### const使用

```C++
// 类
class A
{
private:
    const int a;                // 常对象成员，只能在初始化列表赋值

public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function()
{
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 常指针
    const A &q = a;             // 常引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 常指针变量，指向字符数组常量
    char* const p3 = greeting;          // 常指针，指向字符数组变量
    const char* const p4 = greeting;    // 常指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常指针
void function4(const int& Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
```

## 3.static

作用

- **修饰普通变量**，修改变量的存储区域和生命周期，使**变量存储在静态区**，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。声明为static的局部变量的**生存期不再是当前作用域，而是整个程序的生存期**。
- **修饰普通函数**：表明**函数的作用范围，仅在定义该函数的文件内才能使用**。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
- **修饰成员变量**：**static数据成员是属于类的，不是属于任何具体的对象的，不需要生成对象就可以访问该成员。**static数据成员的初始化必须在类外初始化；
- **修饰成员函数**：修饰成员函数使得**不需要生成对象就可以访问该函数**，但是在 static 函数内不能访问非静态成员，即**static成员函数只能访问static数据成员**或者static成员函数。
- staic变量和普通变量的比较：
  - **staic全局变量只初始化一次**，可以防止在其他文件中被引用；
  - staic局部变量只初始化一次，下次依据上一次的结果值；
  - **static函数在内存中只有与一份**，普通函数在每个被调用中都有一份复制品。



## 4.++i和i++的效率

- 对于内建数据类型，二者效率没有区别；

- 对于自定义数据类型，++i的效率更高。
  - 因为对于自定义类型，前缀式(++i)可以返回对象的引用，后缀式(i++)必须返回对象的值，导致在大对象的时候产生较大的复制开销。



## 5.C和C++的区别

- C语言是面向过程语言，而C++是面向对象语言；
  - 面向过程：面向过程编程就是分析出解决问题的步骤，然后把这些步骤一步一步的实现，使用的时候一个一个的依次调用就可以了。 
  - 面向对象：面向对象编程就是把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。
- 面向过程的语言性能更高，缺点是没有面向对象易维护、易复用、易扩展；
- 面向对象语言有封装、继承、多态性的特性，更灵活但是性能更低。
- 用C实现C++类：
  - 封装：使用函数指针把属性与方法封装到结构体中
  - 继承：结构体嵌套
  - 多态：父类与子类方法的函数指针不同



## 6.this指针

- this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
- 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。
- 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。this指针是类的指针，指向对象的首地址。
- this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
- this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。
- **delete this：**
  - 在类的成员函数中可以调用delete this，调用之后还可以进行其他操作，但是不能涉及这个对象的数据成员和虚函数。
  - 类的析构函数中调用delete this会形成无限递归，导致堆栈溢出。



## 7.inline 内联函数

### 特征

- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

### 使用

```c++
// 声明1（加 inline，建议使用）
inline int functionName(int first, int second,...);

// 声明2（不加 inline）
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```



### 编译器对inline函数的处理步骤

- 将 inline 函数体复制到 inline 函数调用点处；
- 为所用 inline 函数中的局部变量分配内存空间；
- 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
- 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

### 优缺点

- **优点：**
  - 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
  - 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
  - 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
  - 内联函数在运行时可调试，而宏定义不可以。

- **缺点：**
  - 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
  - inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
  - 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。



### 虚函数可以是内联函数吗？

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 虚函数**唯一可以内联的情况**是：编译器知道所调用的对象是哪个类，只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

```C++
class Base {
public:
    inline virtual 
    void who() {
        cout << "I am Base\n";
    }

    virtual ~Base() { }
};

class Derived : public Base {
public:
    inline void who() {  // 不写 inline 时也会隐式内联
        cout << "I am Derived\n";
    }
};

int main() {
    // 此处的虚函数 who()，是通过 Base类的具体对象 b来调用的，
    // 因此编译期间就能确定，所以它可以是内联的，但最终是否内联取决于编译器。
    Base b;
    b.who();

    // 此处的虚函数是通过指针调用的，呈现多态性，
    // 需要在运行时期间才能确定，所以不能为内联。
    Base *ptr = new Derived();
    ptr->who();

    // 因为 Base 有虚析构函数（virtual ~Base() {}），
    // 所以 delete 时，会先调用派生类（Derived）析构函数，
    // 再调用基类（Base）析构函数，防止内存泄漏。
    delete ptr;
    ptr = nullptr;

    return 0;
}
```



## 8.volatile关键字

- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以 volatile 告诉编译器不应对这样的对象进行优化。
- volatile 关键字声明的变量，每次访问时都必须从内存中取出值；没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值。
- const和指针可以是volatile。一个参数可以即是const又是volatile，是volatile是因为它可能被意想不到的被改变，是const告诉程序不应该试图去修改他。



## 9.sizeof和strlen

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得，参数可以是任何数据的类型或者数据；因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。
  - sizeof 对数组，得到整个数组所占空间大小。
  - sizeof 对指针，得到指针本身所占空间大小。

- strlen是字符处理的库函数。strlen的参数只能是字符指针且结尾是'\0'的字符串。
- #pragma pack(n): 设定结构体、联合以及类成员变量以 n 字节方式对齐



## 10.结构体、类和union

- 结构体的默认访问控制权限是public；类是private。

- 一般来说，struct 适合作为一个数据结构的实现体，class 更适合作为一个对象的实现体

- C++中类和结构体都可以继承；

- 在C语言中：

  ```c++
  typedef struct Student {
      int age; 
  } S;
  
  //等价于
  struct Student { 
      int age; 
  };
  
  typedef struct Student S;
  //实际上就是为 struct Student 这个比较长的声明定义了一个别名 S
  ```

- 在C++中：

```C++
typedef 
struct Student { 
    int age; 
} Stu;

void Student() {}           // 正确，定义后名为 "Student" 的函数

// void Stu() {}            // 错误，符号 "Stu" 已经被定义为一个 "struct Student" 的别名

int main() {
    Student(); 
    struct Student s1;
    Stu s2;
    return 0;
}
```

- **Union:联合体**
  - 特点：一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值，当某个成员被赋值后其他成员变为未定义状态。
  - 默认访问控制符为 public；
  - 可以含有构造函数、析构函数；
  - 不能继承自其他类，不能作为基类，不能含有虚函数，不能含有引用类型的成员；
  - 全局匿名联合必须是静态（static）的；



## 11.explicit（显式）关键字

- 如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。
- explicit 修饰构造函数时，可以防止隐式转换和复制初始化；explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外

```c++
struct A
{
	A(int) { }
	operator bool() const { return true; }
};

struct B
{
	explicit B(int) {}
	explicit operator bool() const { return true; }
};

void doA(A a) {}

void doB(B b) {}

int main()
{
	A a1(1);		// OK：直接初始化
	A a2 = 1;		// OK：复制初始化
	A a3{ 1 };		// OK：直接列表初始化
	A a4 = { 1 };		// OK：复制列表初始化
	A a5 = (A)1;		// OK：允许 static_cast 的显式转换 
	doA(1);			// OK：允许从 int 到 A 的隐式转换
	if (a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a6（a1）;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a7 = a1;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化

	B b1(1);		// OK：直接初始化
	B b2 = 1;		// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
	B b3{ 1 };		// OK：直接列表初始化
	B b4 = { 1 };	// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
	B b5 = (B)1;		// OK：允许 static_cast 的显式转换
	doB(1);		// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
	if (b1);	// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
	bool b6(b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
	bool b7 = b1;		// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
	bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化

	return 0;
}
```



## 12.friend 友元类和友元函数

- 能访问私有成员；破坏封装性；友元关系不可传递，单向性；友元声明的形式及数量不受限制；
- 友元函数：不是类的成员函数，却能访问该类所有成员（包括私有成员）的函数。

```C++
class A {
public:
    friend void set_data(int x, A &a);      // 友元函数的声明
    int get_data() { return data; }
private:
    int data;
};

void set_data(int x, A &a) {                // 友元函数的定义
    a.data = x; 
    cout << a.data << endl;                 // 无障碍读写类的私有成员
}
```



- 友元类：一个类的友元类可以访问该类的所有成员（包括私有成员）,但是友元类不可继承，不可传递、单向；

```C++
class A {
public:
    friend class C;    // 友元类的声明：C 是 A 的友元类
private:
    int data;
};

class C {              // 友元类的定义，可以访问 A 中的成员
public:
    void set_A_data(int x, A &a) { 
        a.data = x; 
    }

    int get_A_data(A& a) {
      return a.data;
    }
};
```



- 友元成员函数：使类 B 中的成员函数成为类A的友元函数（但 B 不是 A 的友元类），这样只有类 B 的该成员函数可以访问类 A 的所有成员。一般不会使用，因为友元成员函数涉及两个类的声明和定义顺序。



## 13.::范围解析运算符

- 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
- 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
- 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的



## 14.enum枚举类型

- 限定作用域：使用关键字 enum class，如：enum class open_modes { input, output, append };

- 不限作用域：如

  ```C++
  enum color { red, yellow, green };
  enum { floatPrec = 6, doublePrec = 10 };
  ```



## 15.decltype

- decltype 关键字，选择并返回操作数的数据类型，用于检查实体的声明类型或表达式的类型及值分类。

```c++
// 尾置返回允许我们在参数列表之后声明返回类型
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg)
{
    // 处理序列
    return *beg;    // 返回序列中一个元素的引用
}
// 为了使用模板参数成员，必须用 typename
template <typename It>
auto fcn2(It beg, It end) -> typename remove_reference<decltype(*beg)>::type
{
    // 处理序列
    return *beg;    // 返回序列中一个元素的拷贝
}
const int i = 0;
const int &j = i;
decltype(i) x = 0;    // x 的类型是 const int    
decltype(j) y = x;    // y 的类型是const int&，y 绑定到变量x
int i = 42;
int *p = &i;
int &r = i;
decltype(r) j;         	// j 是引用
decltype(i) e;		// e是一个未初始化的int
decltype((i)) d;	// d是一个int&，这里必须要初始化
decltype(r+0) b;	// b是int
decltype(*p) c;		// c是int&，这里必须要初始化
```



## 16.指针和引用

### 指针和引用的区别：

- 指针是一个具体变量，变量中存储的是一个地址，需要占用存储空间。引用是原变量的一个别名，不占用具体存储空间，只有声明没有定义；
- 初始化不同：引用在创建的同时必须初始化，指针在定义的时候不需要初始化，可以在定义后的后面任何位置重新赋值；
- 可修改性不同：引用一旦初始化之后就不可修改，指针变量可以重新指向别的变量。
- 不存在空引用，引用不能指向空值，而指针可以为NULL；
- 效率：引用不需要测试合法性，故引用的效率比指针要高；
- 安全性：传引用比传指针要安全，因为不存在空引用，而且引用被初始化为指向一个对象后不可以改变。



### 常引用、一般变量引用、指针变量引用：

-  常引用可以理解为常量指针，形式为const typename & refname = varname。常引用下，原变量值不会被别名所修改。原变量的值可以通过原名修改。常引用通常用作只读变量别名或是形参传递。
- 一般变量引用：

```c++
int main() {
	int a = 10;
    int b = 20;
    int &rn = a;//一般变量引用
    int equal;
    
    rn = b;
    cout << a << b << endl;//a=20,b=20
    
    rn = 100;
    cout << a << b << endl;//a=100,b=20
    
    equal = (&a == &rn) ? 1 : 0;//equal = 1
    return 0;
}
```



- 指针变量引用：

```C++
int main() {
    int a = 1;
    int b = 10;
    int* p = &a;//p是指针变量，指向a
    int* &pa = p;//pa是p的引用
    
    (*pa)++;
    cout << a << b << *p << endl;//a=2,b=10,*p=2
    
    pa = &b;
    (*pa)++;
    cout << a << b << *p << endl;//a=2,b=11,*p=11
    return 0;
}
```



### 各种指针的定义：

```C++
int *p[10]//指针数组,强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
int (*p)[10]//表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
int *p(int)//函数声明，函数名是p，参数是int类型的，返回值是int *类型的。即函数返回指针
int (*p)(int)//函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。
int (*p[10])(int)//指向函数的指针数组
```



### 常量指针和指针常量：

- 常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p。

- 指针常量是一个不能给改变指向的指针。如int *const p。



### 函数指针和指针函数：

- 函数指针是指向函数地址的指针；即本质是指针变量，指针变量指向函数，可以通过该指针变量调用函数；

  - 格式：类型说明符 (*函数名)(参数)

    ```C++
    int (*f) (int x); 
    ```

- 指针函数是返回指针类型的函数；即本质是一个函数，返回值是某一类型的指针；

  - 类型标识符    *函数名(参数表)

    ```C++
    int  *f(x，y);
    ```

- 扩展：int(*pa)[8]声明了一个指针，该指针指向了一个有8个int型元素的数组，int* pa[8]声明了一个数组，该数组的每一个元素都是int型的指针



### 数组名和指针：

- 二者均可通过增减偏移量来访问数组中的元素。
- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。
- a和&a的区别：假设数组int a[10];int (*p)[10] = &a;
  - a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
  - &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
  - 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。



### 野指针

- 也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。

- 产生原因及解决办法：
  - 指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。
  - 指针free或delete之后没有及时置空 => 释放操作后立即置空。



## 17.宏

### 宏定义和函数有何区别？

- 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。

- 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。

- 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。

- 宏函数不要在最后加分号。



### 宏定义和const区别？

- 宏替换发生在预编译阶段，属于文本插入替换；const作用发生于编译过程中。

- 宏不检查类型；const会检查数据类型。

- 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。



### 宏定义和typedef区别？

- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。

- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。

- 宏不检查类型；typedef会检查数据类型。

- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。

- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。



### 宏定义和内联函数(inline)区别？

- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。

- 内联函数本身是函数，强调函数特性，具有重载等功能。

- 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。



## 18.malloc和new

### 区别：

- malloc和free是标准库函数，new和delete是运算符，并且支持重载。
- malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。
- malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。
- 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
- new：调用operator new函数申    请空间(operator new 实际是通过malloc来申请空间的)；在申请的空间上执行构造函数，完成对象的构造；
- delete：在空间上执行析构函数，完成对象中资源的清理工作；调用operator delete函数释放对象的空间(operator delete实际是通过free来释放空间的)；
- delete只会调用一次析构函数。delete[]会调用数组中每个元素的析构函数。



## 19.C++的内存管理

### C++内存分区：

- 在C++中，内存区分为5个区，分别是栈区、堆区、自由存储区、全局/静态存储区、常量存储区。

  - **栈区**：编译器自动分配和释放的，存放函数的参数值、局部变量的值等。

  - **堆区**：由程序员手动分配和释放，提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。

  - 自由存储区：是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区，通过delete归还内存。

  - **全局/静态存储区**：全局变量和静态变量存储，在C语言中全局/静态变量又分为初始化的和未初始化的，分别存储在不同段(见下文bss段、data段和text段)，C++中没有这个区分。

  - **常量存储区**：存放的是常量，不允许修改。

    ```C++
    int a = 0; 			 //全局初始化  - 全局/静态存储区
    char *p1;			// 全局未初始化  - 全局/静态存储区
    int b[10];			//全局/静态存储区
    
    int main() {  
    	int b; 				//栈  
    	char s[] = "abc";	 	//栈
    	char* ch= new char[6];	//堆
    	char *p2; 				//栈  
    	char *p3 = "123456"; 	//“123456\0”在常量区，p3在栈上。  
    	static int c =0； 		//静态初始化 - 全局/静态存储区
    	p1 = (char *)malloc(10);  //分配得来得10和20字节的区域就在堆区。  
    	strcpy(p1, "123456"); 	//123456\0放在常量区，编译器可能会将p1与p3所指向的"123456"优化成一个地方。  
        
        return 0;
    }  
    ```



### 堆区和自由存储区的区别和联系：

- 堆区和自由存储区的区别和联系：
  - malloc在堆上分配的内存块，使用free释放内存，而new所申请的内存则是在自由存储区上，使用delete来释放。
  - 堆是操作系统维护的一块内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，调用free()归还内存。
  - 自由存储区是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。
  - C++编译器默认使用堆来实现自由存储，运算符new和delete内部默认是使用malloc和free的方式来被实现，这时由new运算符分配的对象，可以说是在堆上，也可以说是在自由存储区上。
  - new和delete是运算符。运算符可以重载，当new被程序员重载，且内部实现并非只有malloc()时，此时的内存空间就和堆不同了。



### 进程内存分区（bss/data/text)：

- 栈：auto和局部变量 
- 堆：malloc 分配的内存
- bss段：存放程序中未初始化的全局变量；
- 数据段(data段)：存放程序中已初始化的全局变量；
- 代码段(text段)：存放程序执行代码，函数代码
- 一个程序的可执行文件本质上都是由 bss段、data段、text段三个组成的。text和data段都在可执行文件中，由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。



### 堆区和栈区的区别：

- 申请方式不同。
  - 栈由系统自动分配，自动管理，无需手动控制。
  - 堆由程序员手动分配。
- 申请大小限制不同。
  - 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改,栈向低地址方向扩展。Linux下默认情况下为10MB。
  - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。
- 申请效率不同。
  - 栈分配速度快，不会有内存碎片。
  - 堆分配速度慢，且会有内存碎片。



### 类上的内存分布：

- A *a = new A; a->i = 10;的内存分配：
  - A *a：在**栈区**开辟4/8(取决于编译器)字节的空间，分配给指针a。
  - new A：在**堆区**申请类A大小的空间。
  - a = new A：将类A申请到的地址的地址，填入栈中指针a的内存区域。
  - a->i：先找到指针a的地址，通过a的值和i在类a中偏移，得到a->i的地址，然后进行赋值操作。
- 一个类，里面有static，virtual之类的，其内存分配：
  - **static成员变量**：静态数据成员在**全局数据区**分配内存，不属于特定的类对象，属于本类的所有对象共享，在没有产生类对象前就可以使用。
  - **static成员函数**：不具有this指针，在**代码区**分配内存(所有函数都在代码区)。
  - 虚函数：
    - 如果一个类是**局部变量**则该类数据存储在**栈区**；
    - 如果一个类是**通过new/malloc动态申请**的，则该类数据存储在**堆区**。
    - 如果该类是**virutal继承的子类**，则**该类的虚函数表指针和该类其他成员一起存储在堆区**。
    - 类对象的大小就是所有非静态成员变量大小之和 + 虚函数指针大小(多继承下可能为多个) +虚函数表大小(多继承下可能为多个) + 编译器额外增加的字节(字节对齐)。空类至少为1字节。
    - **虚函数表指针**指向**只读数据段中的类虚函数表**，**虚函数表中存放着一个个函数指针**，**函数指针指向代码段中的具体函数**。（虚函数表由于一旦产生就具有不变性，所以编译器就会经量把它放到只读的数据段中-**内存的常量区**。）
    - 虚函数表是是本类的所有对象共享的。
  - 



## 20.extern 

- **1.extern的作用**
  - extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。
  - 当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int test; 
  - 它的作用就是**声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在其他模块中使用**，记住它**是一个声明不是定义**
  - 如果函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义，就是在程序中取代include “*.h”来声明函数
- **2.extern "C":**
  - 意思是其修饰的变量和函数是按照C语言方式编译和连接的。**主要作用就是为了能够正确实现C++代码调用其他C语言代码。**
  - 在C++中，由于C++支持函数重载，而C不支持；C++使用函数名、函数参数数量及函数类型信息编译生成函数名称，如void foo(int a, int b);可能编译生成_foo_int_int。C++靠这种机制实现函数重载。
  - C函数用extern “C”进行链接指定，告诉编译器，保持名称，不要生成用于链接的中间函数名。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。
- **3.extern 和 static**
  - extern 表明该变量在别的地方已经声明过了,在这里要使用那个变量.
  - static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.
  - extern和static不能同时修饰一个变量；const可以与extern连用；
  - static修饰的全局变量声明与定义同时进行，而且static修饰全局变量的作用域只能是本身的编译单元。



## 21.main函数执行前和执行后

- main函数执行前：
  - 设置栈指针
  - 初始化static静态和global全局变量，即data段的内容
  - 将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等bss段的内容
  - 运行全局、静态对象的构造函数；
  - 将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数
- main函数执行后：需要进行资源的释放
  - 用atexit（）函数来注册程序正常终止时要被调用的函数，这些函数在main（）函数结束时被调用，调用的顺序和注册的顺序相反。



## 22.#include <>和""

- 尖括号<>表明这个文件是一个工程或者标准头文件，编译是会先查找预定义的目录(路径环境变量中)
- 双引号""表明该文件是用户提供的头文件，查找时将从当前文件目录开始查找，然后在标准位置查找文件。



## 23.类型转换

- **static_cast**：最常用的类型转换符，在正常状况下的类型转换，如把int转换为float，如：int i；float f； f=（float）i；或者f=static_cast< float >(i)
- **dynamic_cast**：
  - 基类指针/引用安全向下转换到派生类指针/引用，提供运行时的类型检查；如果成功的话返回的是指向类的指针或引用，指针转换失败的话则会返回NULL，引用转换失败抛出异常。 dynamic_cast<source>
  - 其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。
  - 不能用于内置的基本数据类型的强制转换。
  - **使用dynamic_cast进行转换的，基类中一定要有虚函数**
  - dynamic_cast主要用于类层次间的安全的上行转换和下行转换或跨系转型。**在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。**  
- **const_cast**：去除const属性，转换为非const属性
- **reinterpret_cast**：常用于转换函数指针类型，假设有一个数组存储是函数指针，有特定类型。把其他类型的函数指针放入这个数组。 尽量避免使用
- C++不是类型安全的，因为存在强制类型转换。



## 24.内存对齐

- 为什么进行内存对齐？
  - 经过内存对齐之后，CPU的内存访问速度大大提升。
  - 不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据。
- **内存对齐的规则**：
  - **第一个成员的首地址为0**；
  - **结构体内成员按自身按自身长度自对齐**；
    - 自身长度，如char=1，short=2，int=4，double=8，指针4/8字节；
    - 所谓自对齐，指的是该成员的起始位置的内存地址必须是它自身长度的整数倍。
    - 如int只能以0,4,8这类的地址开始
  - **结构体的总大小为结构体的有效对齐值的整数倍**；
    - 当未明确指定时，以结构体中最长的成员的长度为其有效值；
    - 当用 #pragma pack(n) 指定时，以 n 和结构体中最长的成员的长度中较小者为其值。
    - 当用__attribute__ ((__packed__)) 指定长度时，强制按照此值为结构体的有效对齐值,如果 pragma pack 和__attribute__ 同时指定呢？以__attribute__ 的为准。
- 举例：

```C++
##例一
struct test1 {
    char a;
    int b;
    char c; 
};

sizeof(test1) = 12;
/*解释:结构体内存起始地址为 0，那么地址的分布如下
0 1 2 3 4 5 6 7 8 9 10 11
a       b b b b c        

char 的字对齐长度为 1，可以在任何地址开始，但是int 自对齐长度为 4，必须以 4 的倍数地址开始。所以，尽管 1-3 空着，但 b 也只能从 4 开始。再加上 c 后，整个结构体的总长度为 9，结构体的有效对齐值为其中最大的成员即 int 的长度 4，所以，结构体的大小向上扩展到 12，即 9-11 的地址空着。*/

##例二
struct test2 {
    char a;
    char c; 
    int b;    
};
sizeof(test2) = 8
/*解释:结构体内存起始地址为 0，那么地址的分布如下
0 1 2 3 4 5 6 7
a c     b b b b      

char 的字对齐长度为 1，int 自对齐长度为 4，所以变量b只能从4位置开始，且结构体的有效对齐值为其中最大的成员为int，最终字节长度为8。*/
    
##例三
#pragma pack(2)
struct test4 {
    char a;
    int b;
    char c; 

};
sizeof(test4)=10//a 到 c 只占 9 字节长度，因为结构体的有效对齐长度在 pack 指定的 2 和 int 的 4 中取较小的值 2。故取 2 的倍数 10。
    
##例四
struct test5 {
    char a;
    int b;
    char c; 
}__attribute__((__8__));
sizeof(test5) = 16// a 到 c 仍然只占 9 字节长度，但结构体以 8 对齐，故取 8 的倍数 16.如果其指定 2，则结果为 10

```

- 

- 其他注意：
  - 静态变量和静态函数不占有类的内存空间；
  - 变量定义的位置的不同时有可能影响结构体的大小
  - 64位系统下：char-1、指针变量-8、int-4、float-4、long-8、double-8、虚函数表-8
  - 32位系统下：char-1、指针变量-4、int-4、float-4、long-8、double-8、虚函数表-4



## 25.final和override

- final：不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字；
- override：显式指定了子类的这个虚函数是重写的父类的



## 26.成员初始化列表和列表初始化

### 成员初始化列表：

- 优点：更高效：少了一次调用默认构造函数的过程。
- 成员初始化列表的初始化顺序和声明顺序有关，和写的先后顺序无关；
- **const常量数据成员**，**引用类型**，**没有默认构造函数的类**类型，这三者必须使用成员初始化列表进行初始化。



- 赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。二者的主要区别在于：在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。列表初始化是给数据成员分配内存空间时就进行初始化。



### initializer_list 列表初始化：

- 用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数.



## 27.内存泄漏

### 内存泄漏产生的原因：

- 未释放已经不再使用的内存，内存泄漏并不是指内存物理上的消失，而是指对该段内存失去了控制；
  - 堆内存泄漏：如在释放对象数组时在delete中没有使用方括号，或者未使用delete；
  - 系统资源泄漏：如套接字、文字描述符、管道等没有使用对应的函数释放掉。
- 内存溢出：指程序在申请内存时，没有足够的内存空间供其使用；
- 段错误：在访问非法内存地址，如使用野指针、试图修改字符串常量的内容、操作越界等；使用GDB进行调试



### 内存泄漏如何避免：

- 以构造函数获取资源(内存),析构函数释放-即RAII；
- 相比于使用原生指针，更建议使用智能指针；
- 注意delete和delete[]；



## 28.C++的异常机制：

- 程序使用throw关键字抛出异常表达式，然后执行程序的当前异常处理代码块的try块，依次匹配catch语句中的异常对象；
- 栈展开：抛出异常时，将暂停当前函数的执行，开始查找匹配的catch子句。首先检查throw本身是否在try块内部，如果是，检查与该try相关的catch子句，看是否可以处理该异常。如果不能处理，就退出当前函数，并且释放当前函数的内存并销毁局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的catch。
- 析构函数的执行不应该抛出异常：如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
  - 解决方案：
    - 把异常完全封装在析构函数内部，决不让异常抛出函数之外；
    - 构造抛异常之前必须把已经申请的资源释放掉。
- 构造函数中抛出异常时：
  - C++中通知对象构造失败的唯一方法那就是在构造函数中抛出异常；
  - 构造函数中抛出异常将导致对象的析构函数不被执行；
  - 当对象发生部分构造时，已经构造完毕的子对象将会逆序地被析构；



## 29.智能指针

### 什么是智能指针

- 智能指针是存储指向堆上动态分配对象指针的类，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露，利用自动调用类的析构函数来释放内存。boost库。



### 为何使用？

- 手动 malloc/new 出来的资源，容易忘记 free/delete；
- 影响执行流的地方需要注意释放释放资源，容易导致资源泄漏，如 free/delete 在 return 之后；
- 中途抛出异常，无法释放资源。
- 智能指针的作用原理就是自动释放内存空间，不需要手动释放内存空间。



### 原理

- 它的一种通用实现技术是使用引用计数，除此之外还有资源独占，如auto_ptr, 只引用，不计数的weak_ptr。
- 智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。
  - 每次创建类的新对象时，初始化指针并将引用计数置为 1；
  - 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；
  - 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至 0，则删除对象），并增加右操作数所指对象的引用计数；
  - 调用析构函数时，构造函数减少引用计数
  - 如果引用计数减至 0，则删除基础对象
- 创建一份资源出来的时候，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。除此之外，通过运算符重载（重载 * 和 -> 等），可以向指针一样使用。



### shared_ptr、unique_ptr、weak_ptr、auto_ptr

- **auto_ptr**: C++11已经弃用，

  - 采用所有权模式。缺点是：存在潜在的内存崩溃问题

  - 不支持拷贝构造函数和赋值（operator =），但复制或赋值的时候不会提示出错。因为不能被复制，所以不能被放入容器中。

  - 如：

    ```c++
    auto_ptr<string> p1(new string("Hello"));
    auto_ptr<string> p2;
    
    p2 = p1; //auto_ptr不会报错.p2剥夺了p1的所有权
    //当程序运行时访问p1将会报错
    ```

    

- **unique_ptr:** C++11引入替换auto_ptr。

  - unique_ptr是独占式拥有或严格拥有概念，保证**同一时间内只有一个智能指针可以指向该对象**。

  - 还是上面那个例子，就会编译报错；因此，unique_ptr比auto_ptr更安全。

  - 当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做。

  - 例如：

    ```C++
    unique_ptr<string> pu1(new string ("hello"));
    unique_ptr<string> pu2;
    pu2 = pu1; //不允许-move可以把一个unique_ptr赋给另一个
    //move(pu1)后，那块内存归pu2所有, pu1成为无效的指针.
    unique_ptr<string> pu3;
    pu3 = unique_ptr<string>(new string ("You")); //允许-临时右值，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。
    ```

    

- **shared_ptr**：解决 auto_ptr 在对象所有权上的局限性,auto_ptr 是独占的
  
  - 多个智能指针可以共享同一个对象，采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。
  - 构造加一，拷贝构造加一、赋值时左值减一，右值加一、析构减一
  - 对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过**get函数**获得普通指针(unique_ptr赋值给shared_ptr)。
  
- **weak_ptr**：
  
  - weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象,
  - 目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。
  - 用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。引入weak_ptr把其中一个改为weak_ptr就可以解决这个问题。
  - weak_ptr 和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。
- 



### 智能指针有没有内存泄露

- 当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数永远不会减少，从而导致内存泄漏。
- 解决方案：引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。



### 实现智能指针



## 30.模板

- 用于解决多个功能相同、数据类型不同的类需要重复定义的问题。
- 在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。
- 类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。
- 编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。
- 函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。



## 31.如何定义一个只能在堆/栈上生成对象的类

### 只能在堆上

- 方法：将析构函数设置为私有

- 原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

### 只能在栈上

- 方法：将 new 和 delete 重载为私有

- 原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。



## 32.RTTI-运行时类型检查

- 在C++层面主要体现在
  - dynamic_cast(用于多态类型的转换)
  - typeid运算符允许在运行时确定对象的类型,type_id 返回一个 type_info 对象的引用
  - type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 t
- 虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info



## 33.函数传参

- **值传递**：值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了**实参的一个副本**。
- **指针参数传递**：指针参数传递本质上是值传递，它所传递的是一个地址值。对形参指针的任何操作都是**作为局部变量**进行的，**不会影响主调函数的实参变量的值**
- **引用参数传递**：被调函数的形式参数也作为**局部变量**在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。所有操作都是通过栈中存放的地址**访问主调函数中的实参变量本身**，对形参的任何操作都**会影响主调函数中的实参**。
- 形参和实参：
  - 形参：只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元；是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。
  - 实参：实际参数，可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。   
- 



## 34.左值、右值和右值引用

- 左值：
  - 出现在 operator= 左侧，可被取地址，如有名称的变量、**函数形参**（栈中的对象）等
- 右值：
  - 只能出现在 operator= 右侧，不可取地址，如：字面常量（如1、2…等）、匿名对象（临时对象）以及函数的返回值等。另外，也可以通过 std::move 显式地将一个左值转换为右值。
  - 一个表达式的值要么是 左值，要么是 右值。
- 右值引用：
  - 左值引用通过在类型之后加一个“&”来定义，如：A a;   A& a_ref1 = a; 
  - 右值引用则在某个类型之后添加两个“&”，如：A a;      A&& a_ref2 = a; 
  - 右值引用的行为跟左值引用类似，不同之处在于：右值引用可以绑定到临时量（右值），而（非const的）左值引用却不能绑定到右值。
    - A& a_ref3 = A(); // Error - 左值
    - A&& a_ref4 = A(); // Ok- 右值
  - 右值引用的目的主要是为了是减少内存拷贝，优化性能。
- move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转义，没有内存拷贝。因此对vector来说，我们完全可以期待move()会使其参数成为容量为0的vector，从而避免复制所有元素。换言之，move有可能是破坏性的读取。
- forward将左值转换为右值。
- 右值引用的第一项任务就是允许我们实现move()而无须使用冗长的代码或引入运行时开销。



35.



# 二、面向对象

## 1.封装

- **封装**：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。



### public/protected/private的区别

- public 成员：可以被任意实体访问
- protected 成员：只允许被子类及本类的成员函数访问
- private 成员：只允许被本类的成员函数、友元类或友元函数访问



## 构造函数和析构函数抛出异常

- 构造函数可以抛出异常，但是抛出异常会导致析构函数不能被调用，但是对象本身已经申请的内存资源会被系统释放，已申请的资源的内部成员变量会被系统依次逆序调用其析构函数；可能会造成内存泄漏；
- 析构函数不可以抛出异常；如果析构函数抛出异常，异常之后的动作将不会被执行，会导致一些资源不会被释放，通常异常发生时，C++机制会调用已经构造函数的析构函数来释放资源，此时若析构函数本身也抛出异常，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又会有新的异常，会导致程序崩溃问题。应该把析构函数的异常封装在析构函数内部。



### 空类包含的函数：

- 构造函数（默认无参构造函数、一般构造函数）

- 析构函数

- 拷贝构造函数

- 赋值运算符

```C++
class Empty {
public:
    Empty();							//默认构造函数
    Empty(const Empty &);				//复制构造函数
    ~Empty();							//析构函数
    Empty& operator=(const Empty &);	//赋值运算符
    Empty* operator&();					//取值运算符
    const Empty* operator&() const;		//取值运算符 const
};
```



### 拷贝构造函数中深拷贝和浅拷贝区别

- 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。

- 浅拷贝仅仅是拷贝指针字面值。当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。




### 临时对象

- 产生的原因：
  - 作为参数按值传递；
  - 返回值按值传递；

- 如何避免产生临时变量：使用按引用传递代替按值传递。



## 2.继承

让某种类型对象获得另一个类型对象的属性和方法。基类（父类）—> 派生类（子类）



### 抽象类、接口类、聚合类

- 抽象类：含有纯虚函数的类
- 接口类：仅含有纯虚函数的抽象类
- 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
  - 所有成员都是 public
  - 没有定义任何构造函数
  - 没有类内初始化
  - 没有基类，也没有 virtual 函数



### 私有继承和组合

- 相同点：都可以表示“有一个”的关系；即派生类和基类不是“is a”关系，而是以...实现的关系，只是派生类想用基类中的一些方法。
- 不同点：私有继承中派生类能访问基类的protected成员，并且可以重写基类的虚函数；甚至当基类为抽象类。组合不具有这些功能。



### 构造函数的调用顺序

- 任何**虚拟基类的构造函数**按照他们被继承的顺序构造
- 任何**非虚拟基类的构造函数**按照他们被继承的顺序构造
- 任何**成员对象的构造函数**按照他们声明的顺序构造
- **类自己的构造函数**



### 析构函数的调用顺序

与构造顺序正好相反

- 派生类本身的析构函数
- 对象成员析构函数
- 基类析构函数
- 特例 
  - 局部对象，在退出程序块时析构
  - 静态对象，在定义所在文件结束时析构
  - 全局对象，在程序结束时析构 
- 继承对象，先析构派生类，再析构父类 
- 对象成员，先析构类对象，再析构对象成员



### 拷贝构造函数和赋值运算符重载的区别

- 拷贝构造函数是函数，赋值运算符是运算符重载。
- 拷贝构造函数是一个对象来初始化一块内存区域，会生成新的类对象，赋值运算符不能。
- 拷贝构造函数是一个构造函数，调用的时候通过参数传递进来的那个对象来初始化产生一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；
- 赋值运算符是把一个对象赋值给一个原有的对象，如果原来的对象有内存分配，要先把内存释放掉，还要检查两个对象是不是同一个对象，如果是，则无需进行任何操作。
- 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：

```C++
Student s;
Student s1 = s;    // 调用拷贝构造函数
Student s2;
s2 = s;    // 赋值运算符操作
```

- 类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。



## 3.多态

同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为。



### 什么是多态

- 定义：向不同对象发送同一消息，不同的对象在接收时会产生不同的行为。
- 编译时多态：重载
- 运行时多态：虚函数



### 重载(overide)和重写(overload)的区别

- 重载：编译时多态。编写一个已有函数名，但是参数列表不同的方法。
  - 方法名必须相同；
  - 参数列表必须不同；
  - 返回值类型可以不同。

- 重写：运行时多态。派生类重写基类的虚函数。
  - 只有虚方法和抽象方法才能被重写；
  - 函数名、参数列表、返回值类型必须相同；
  - 派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。



### 虚函数是如何实现的

- 虚函数是通过虚函数表实现的。
- 目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数，实现运行时多态。
- 如果类中含有虚函数，系统会为这个类分配一个指针成员(虚函数表指针)和一个虚函数表，虚函数表中的每一项都指向一个虚函数的地址。可以把虚函数表理解成一个函数指针的数组。
- 在类对象的内存布局中，首先是该类的虚函数表指针，然后才是对象数据成员，在通过对象指针调用一个虚函数时，编译器生成的代码会先获取对象类的虚函数表指针，然后调用虚函数表中对应的项，从而正确实现动态的对象函数调用。
- 虚函数表是和类对应的，虚函数表指针是和对象对应的。编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。
- 缺点：虚函数最主要的缺点是执行效率较低，而且因为要保存虚函数表，类多占的内存空间也会比较大，对象也是一样的。



### 虚继承

- 虚继承用于解决多继承条件下浪费存储空间、存在二义性等问题。
- 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；
- 当虚继承的子类被当做父类继承时，虚基类指针也会被继承。
- 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。
- 虚继承、虚函数
- 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
- 不同之处：
  - 虚继承
    - 虚基类依旧存在继承类中，只占用存储空间
    - 虚基类表存储的是虚基类相对直接继承类的偏移
  - 虚函数
    - 虚函数不占用存储空间
    - 虚函数表存储的是虚函数地址



### 哪些函数不能是虚函数

- 构造函数：对象的虚函数表指针需要通过构造函数初始化
- 内联函数：内联函数可以在编译阶段进行函数体的替换，而虚函数需要在运行期间进行确定
- 静态函数：静态函数不属于对象而属于类，因为静态成员函数没有this指针，所以无法访问对象的虚表指针，也就无法访问类的虚函数表，将静态函数设置成虚函数也就没有任何意义，所以c++语法不支持将静态函数设置成虚函数
- 友元函数：友元函数不属于类，也不能被继承，没有继承特性的函数没有虚函数的说法



### 虚函数和纯虚函数的区别

- 虚函数的作用是为了让它的子类里面可以被覆盖，这样编译器可以后期绑定来达到多态；纯虚函数只是一个接口，要在子类中实现；
- 虚函数在派生类中可以不重载，但是纯虚函数必须在子类中实现；
- 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。纯虚函数最显著的特征是：它们必须在继承类中重新声明函数



### 虚析构函数

- 当父类的析构函数声明成虚析构函数时，当子类继承父类，父类指针指向子类对象，delete掉父类指针，先调用子类的析构函数，然后调动父类的析构函数，不存在子类对象内存泄漏的问题。
- 只有一个类是基类时，才会把析构函数写成虚函数。
- 析构函数可以是纯虚函数。
- C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。



### 构造函数和析构函数调用虚函数

- 在构造函数调用虚函数：虚机制不会发生作用，因为基类的构造函数在派生类构造函数之前执行，当执行基类构造函数时，派生类的数据成员还没被初始化，如果此时调用虚函数，向下匹配到派生类中，派生类的数据成员还没被初始化，这时访问的是未被初始化的部分。所以虚函数不会向下匹配到派生类，而是执行执行基类的函数，就没有多态性了。
- 析构函数亦然，一旦派生类的析构函数开始执行，对象内的派生类成员就是未定义的，如果这时再进入基类的析构函数中，调用的虚函数必然是基类的，因为派生类已经不是一个完整的类型了。



### 构造函数为什么不能为虚函数

- 因为虚函数表指针必须在构造函数中初始化，所以构造函数不能为虚函数
  



# 三、STL



## 什么是STL

- 即标准模板库，是C++标准函数库的子集。
- 包含容器、算法、迭代器、仿函数、配接器、空间配置器



## STL的实现简介

- 序列容器：
  - vector：动态数组；
  - list：双向链表；
  - deque：双端队列
- 关联容器：
  - set/multiset：红黑树
  - map/multimap：红黑树
  - hash_set/hash_multiset：哈希表
  - hash_map /hash_multimap：哈希表
  - unordered_map ：哈希表
- 适配容器：
  - stack：deque / list（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）
  - queue：deque / list
  - priority_queue：vector + heap
- 



## STL的内存配置

- stl对于小内存块请求与释放的处理：
  - STL设计了双层级配置器，第一级配置直接使用malloc()和free()；第二级配置器则视情况采用不同的策略
    - 当配置区大于128bytes时，直接调用第一级配置器；
    - 当配置区块小于128bytes时，便不借助第一级配置器，而使用一个内存池来实现。究竟是使用第一级配置器还是第二级配置器，由一个宏定义来控制。SGI STL中默认使用第二级配置器。
  - 二级配置器会将任何小额区块的内存需求量上调至8的倍数，(例如需求是30bytes,则自动调整为32bytes)，并且在它内部会维护16个free-list， 各自管理大小分别为8， 16， 24，…，128字节的小额区块，这样当有小额内存配置需求时，直接从对应的free list中拔出对应大小的内存(8的倍数)；当客户端归还内存时，将根据归还内存块的大小，将需要归还的内存插入到对应free list的最顶端。
- 小结：STL中的内存分配器实际上是基于空闲列表(free list)的分配策略，最主要的特点是通过组织16个空闲列表，对小对象的分配做了优化。
- 小对象的快速分配和释放。当一次性预先分配好一块固定大小的内存池后，对小于128字节的小块内存分配和释放的操作只是一些基本的指针操作，相比于直接调用malloc/free，开销小。
- 避免内存碎片的产生。零乱的内存碎片不仅会浪费内存空间，而且会给OS的内存管理造成压力。
- 尽可能最大化内存的利用率。当内存池尚有的空闲区域不足以分配所需的大小时，分配算法会将其链入到对应的空闲列表中，然后会尝试从空闲列表中寻找是否有合适大小的区域，
- 一个通用的内存分配器是不需要知道待释放内存的大小的，类似于free(p)。



## vector

- 动态数组，需要连续的物理存储空间。支持随机访问。
- vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。
- 如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。
- 内部使用allocator类进行内存管理，无需程序员自己操作内存。
- 在中间插入会内存拷贝；
- 迭代器失效：
  - insert时：
    - 尾后插入：size < capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。
    - 中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。
  - erase时：
    - 尾后删除：只有尾迭代失效。
    - 中间删除：删除位置之后所有迭代失效。
- clear()并不释放内存，swap会释放内存，
- auto_ptr不能做vector的元素：因为STL的标准容器规定它所容纳的元素必须是可以拷贝构造和可被转移赋值的。而auto_ptr不能，可以用shared_ptr智能指针代替。
- begin返回的是第一个元素的迭代器，end返回的是最后一个元素后面位置的迭代器。
- 遍历方式：迭代器遍历、下标遍历、auto遍历
- 并不是线程安全的



## list

- 动态链表，在堆上分配空间，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间。不支持随机存取。
- 链表的插入操作时常数时间复杂度，访问操作是O(n)。
- list和vector的比较：
  - **vector：底层实现是数组，连续的内存空间，支持随机存取，在中间节点进行插入删除会导致内存拷贝，一次性分配好内存，不够时才进行2倍扩容，随机访问性能好，插入删除性能差；**
  - **list：底层实现是双向链表，内存空间不连续，不支持随机存取，中间插入或者删除不会导致内存拷贝，每次插入新节点都会进行内存申请，随机访问性能差，插入删除性能好。**
- 



## deque

- deque动态地以分段连续空间组合而成，随时可以增加一段新的连续空间并链接起来。不提供空间保留功能。
- deque采用一块map（不是STL的map容器）作为主控，其为一小块连续空间，其中每个元素都是指针，指向另一段较大的连续空间（缓冲区）。
- deque是双向开口的连续线性空间。双向开口是指可以在头尾两端分别做元素的插入和删除操作。



## set

- set和multiset会根据特定的排序准则自动将元素排序，
- set中元素不允许重复，multiset可以重复。
- 因为是排序的，所以set中的元素不能被修改，只能删除后再添加。



## map

- map和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序，map<key,value>
- map中元素的key不允许重复，multimap可以重复。
- 因为是排序的，所以map中元素的key不能被修改，只能删除后再添加。key对应的value可以修改。
- 查找的时间复杂度是O(logn)
- 不能边遍历边插入
- stl::map 的key需要定义operator<
- 插入：map.insert和map[i]=...，前者是重复插入失败，后者是重复替换value值
- greater<int>和less<int>，前者表示按照int值从大到小排序，后者表示从小到大排序
- 每次insert之后，以前保存的iterator不会失效，因为



## 为何map和set不能用reserve函数来预分配数据？

- map和set内部存储的已经不是元素本身了，而是包含元素的节点。也就是说map内部使用的Alloc并不是map声明的时候从参数中传入的Alloc。
- 例如：map, Alloc > intmap;
- 这时候在intmap中使用的allocator并不是Alloc, 而是通过了转换的Alloc，具体转换的方法时在内部通过Alloc::rebind重新定义了新的节点分配器



## hash_map/unordered_map和map的区别

- 构造函数 unordered_map需要hash函数，等于函数;map只需要比较函数(小于函数).
- 存储结构 unordered_map采用hash表存储，map一般采用红黑树实现。因此其数据结构是不一样的。
- 什么时候用unordered_map,什么时候用map?
  - 权衡三个因素: 查找速度, 数据量, 内存使用。
  - unordered_map底层是散列的所以理论上操作的平均复杂度是常数时间，map底层是红黑树，理论上平均复杂度是O(logn)
  - 选用map还是unordered_map，关键是看关键字查询操作次数，以及你所需要保证的是查询总体时间还是单个查询的时间。
  - 如果是要很多次操作，要求其整体效率，那么使用unordered_map，平均处理时间短。
  - 如果是少数次的操作，使用 unordered_map可能造成不确定的O(N)，那么使用平均处理时间相对较慢、单次处理时间恒定的map，考虑整体稳定性应该要高于整体效率，因为前提在操作次数较少。



## 红黑树

- 树状结构
  - 插入删除不需要数据复制。
  - 操作复杂度仅跟树高有关。
- 红黑树本身也是二叉排序树的一种，key值有序，且唯一。
  - 必须保证key可排序。
- 基于红黑树实现的map结构（map, set, multimap，multiset底层均是红黑树），不仅增删数据时不需要移动数据，
- 其所有操作都可以在O(logn)时间范围内完成。
- 基于红黑树的map在通过迭代器遍历时，得到的是key按序排列后的结果。
- 要求：
  - 树中所有节点非红即黑。
  - 根节点必为黑节点。
  - 叶子节点(NULL节点)一定为黑。
  - 红节点的子节点必为黑（黑节点子节点可为黑）。
  - 从根到NULL的任何路径上黑结点数相同。
- 查找时间一定可以控制在O(logn)。
- 相比于AVL树(平衡二叉树)，红黑树平衡性要稍微差一些，不过创建红黑树时所需的旋转操作也会少很多。红黑数插入和删除最多只需要3次旋转。
- 相比于最简单的二叉搜索树BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。
- 从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列......最长路径不会大于2n，这里路径长就是树高。



## 哈希表冲突处理方法

- 链地址法：key 相同的用单链表链接
- 开放定址法
  - 线性探测法：key 相同 -> 放到 key 的下一个位置，Hi = (H(key) + i) % m
  - 二次探测法：key 相同 -> 放到 Di = 1^2, -1^2, ..., ±（k)^2,(k<=m/2）
  - 随机探测法：H = (H(key) + 伪随机数) % m
-  STL中hash_map扩容发生什么？
  - 创建一个新桶，该桶是原来桶两倍大最接近的质数(判断n是不是质数的方法：用n除 2到sqrt(n)范围 内的数) ；
  -  将原来桶里的数通过指针的转换，插入到新桶中(注意STL这里做的很精细，没有直接将数据从旧桶遍历拷贝数据插入到新桶，而是通过指针转换)
  - 通过swap函数将新桶和旧桶交换，销毁新桶。  



## 红黑树、B 树、B+ 树的区别

- 红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些
- B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。
- 大部分文件系统、数据库系统都采用B树、B+树作为索引结构
- B树和B+树的区别：
  - B+树中只有叶子节点会带有指向记录的指针，而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。
  - B+树中所有叶子节点都是通过指针连接在一起，而B树不会。
- B树的优点：对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。
- B+树的优点
  - 非叶子节点不会带上指向记录的指针，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。
  - 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。
- mysql使用B+树作为索引，linux中进程的调度用的是红黑树，文件系统使用B树作为索引。



## 迭代器删除元素

是迭代器失效的问题。

- 对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；
- 对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
- 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。



## 为何map和set的插入删除效率比用其他序列容器高

- 因为对于关联容器来说，不需要做内存拷贝和内存移动。



## STL的sort

- 在数据量大时，采用快排，分段递归排序；一旦分段后的数量小于某个门限值，改用插入排序，避免quicksort深度递归带来的过大的额外负担，如果递归层次过深，还会改用堆排序。

